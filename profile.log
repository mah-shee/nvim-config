SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/EasyMotion.vim
Sourced 1 time
Total time:   0.006712
 Self time:   0.003005

count  total (s)   self (s)
    1              0.000015 scriptencoding utf-8
                            " EasyMotion - Vim motions on speed!
                            "
                            " Author: Kim Silkeb√¶kken <kim.silkebaekken+vim@gmail.com>
                            "         haya14busa <hayabusa1419@gmail.com>
                            " Source: https://github.com/easymotion/vim-easymotion
                            "=============================================================================
                            " Saving 'cpoptions' {{{
    1              0.000020 let s:save_cpo = &cpo
    1   0.000075   0.000063 set cpo&vim
                            " }}}
                            
    1              0.000013 let s:TRUE = !0
    1              0.000006 let s:FALSE = 0
    1              0.000015 let s:DIRECTION = { 'forward': 0, 'backward': 1, 'bidirection': 2}
                            
                            
                            " Init: {{{
    1              0.000007 let s:loaded = s:FALSE
    1              0.000018 function! EasyMotion#init()
                                if s:loaded
                                    return
                                endif
                                let s:loaded = s:TRUE
                                call EasyMotion#highlight#load()
                                " Store previous motion info
                                let s:previous = {}
                                " Store previous operator-pending motion info for '.' repeat
                                let s:dot_repeat = {}
                                " Prepare 1-key Migemo Dictionary
                                let s:migemo_dicts = {}
                                let s:EasyMotion_is_active = 0
                                call EasyMotion#reset()
                                " Anywhere regular expression: {{{
                                let re = '\v' .
                                    \    '(<.|^$)' . '|' .
                                    \    '(.>|^$)' . '|' .
                                    \    '(\l)\zs(\u)' . '|' .
                                    \    '(_\zs.)' . '|' .
                                    \    '(#\zs.)'
                                " 1. word
                                " 2. end of word
                                " 3. CamelCase
                                " 4. after '_' hoge_foo
                                " 5. after '#' hoge#foo
                                let g:EasyMotion_re_anywhere = get(g:, 'EasyMotion_re_anywhere', re)
                            
                                " Anywhere regular expression within line:
                                let re = '\v' .
                                    \    '(<.|^$)' . '|' .
                                    \    '(.>|^$)' . '|' .
                                    \    '(\l)\zs(\u)' . '|' .
                                    \    '(_\zs.)' . '|' .
                                    \    '(#\zs.)'
                                let g:EasyMotion_re_line_anywhere = get(g:, 'EasyMotion_re_line_anywhere', re)
                                "}}}
                                " For other plugin
                                let s:EasyMotion_is_cancelled = 0
                                " 0 -> Success
                                " 1 -> Cancel
                                let g:EasyMotion_ignore_exception = 0
                                return ""
                            endfunction
                            "}}}
                            " Reset: {{{
    1              0.000007 function! EasyMotion#reset()
                                let s:flag = {
                                    \ 'within_line' : 0,
                                    \ 'dot_repeat' : 0,
                                    \ 'regexp' : 0,
                                    \ 'bd_t' : 0,
                                    \ 'find_bd' : 0,
                                    \ 'linewise' : 0,
                                    \ 'count_dot_repeat' : 0,
                                    \ }
                                    " regexp: -> regular expression
                                    "   This value is used when multi input find motion. If this values is
                                    "   1, input text is treated as regexp.(Default: escaped)
                                    " bd_t: -> bi-directional 't' motion
                                    "   This value is used to re-define regexp only for bi-directional 't'
                                    "   motion
                                    " find_bd: -> bi-directional find motion
                                    "   This value is used to recheck the motion is inclusive or exclusive
                                    "   because 'f' & 't' forward find motion is inclusive, but 'F' & 'T'
                                    "   backward find motion is exclusive
                                    " count_dot_repeat: -> dot repeat with count
                                    "   https://github.com/easymotion/vim-easymotion/issues/164
                                let s:current = {
                                    \ 'is_operator' : 0,
                                    \ 'is_search' : 0,
                                    \ 'dot_repeat_target_cnt' : 0,
                                    \ 'dot_prompt_user_cnt' : 0,
                                    \ 'changedtick' : 0,
                                    \ }
                                    " \ 'start_position' : [],
                                    " \ 'cursor_position' : [],
                            
                                    " is_operator:
                                    "   Store is_operator value first because mode(1) value will be
                                    "   changed by some operation.
                                    " dot_* :
                                    "   These values are used when '.' repeat for automatically
                                    "   select marker/label characters.(Using count avoid recursive
                                    "   prompt)
                                    " changedtick:
                                    "   :h b:changedtick
                                    "   This value is used to avoid side effect of overwriting buffer text
                                    "   which will change b:changedtick value. To overwrite g:repeat_tick
                                    "   value(defined tpope/vim-repeat), I can avoid this side effect of
                                    "   conflicting with tpope/vim-repeat
                                    " start_position:
                                    "   Original, start cursor position.
                                    " cursor_position:
                                    "   Usually, this values is same with start_position, but in
                                    "   visualmode and 'n' key motion, this value could be different.
                                return ""
                            endfunction "}}}
                            
                            " Motion Functions: {{{
                            " -- Find Motion -------------------------
                            " Note: {{{
                            " num_strokes:
                            "   The number of input characters. Currently provide 1, 2, or -1.
                            "   '-1' means no limit.
                            " visualmode:
                            "   Vim script couldn't detect the function is called in visual mode by
                            "   mode(1), so tell whether it is in visual mode by argument explicitly
                            " direction:
                            "   0 -> forward
                            "   1 -> backward
                            "   2 -> bi-direction (handle forward & backward at the same time) }}}
    1              0.000006 function! EasyMotion#S(num_strokes, visualmode, direction) " {{{
                                if a:direction == 1
                                    let is_inclusive = 0
                                else
                                    " Note: Handle bi-direction later because 'f' motion is inclusive but
                                    " 'F' motion is exclusive
                                    let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                endif
                                let s:flag.find_bd = a:direction == 2 ? 1 : 0
                                let re = s:findMotion(a:num_strokes, a:direction)
                                if s:handleEmpty(re, a:visualmode) | return | endif
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#OverwinF(num_strokes) " {{{
                                let re = s:findMotion(a:num_strokes, s:DIRECTION.bidirection)
                                call EasyMotion#reset()
                                if re isnot# ''
                                    return EasyMotion#overwin#move(re)
                                endif
                            endfunction "}}}
    1              0.000004 function! EasyMotion#T(num_strokes, visualmode, direction) " {{{
                                if a:direction == 1
                                    let is_inclusive = 0
                                else
                                    " Note: Handle bi-direction later because 't' motion is inclusive but
                                    " 'T' motion is exclusive
                                    let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                endif
                                let s:flag.find_bd = a:direction == 2 ? 1 : 0
                                let re = s:findMotion(a:num_strokes, a:direction)
                                if s:handleEmpty(re, a:visualmode) | return | endif
                                if a:direction == 2
                                    let s:flag.bd_t = 1
                                elseif a:direction == 1
                                    let re = s:convert_t_regexp(re, 1) " backward
                                else
                                    let re = s:convert_t_regexp(re, 0) " forward
                                endif
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Word Motion -------------------------
    1              0.000003 function! EasyMotion#WB(visualmode, direction) " {{{
                                "FIXME: inconsistent with default vim motion
                                "FIXED: -> EasyMotion#WBK()
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion('\(\<.\|^$\)', a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#WBW(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let regex_without_file_ends = '\v(^|\s)\zs\S|^$'
                                let regex = l:regex_without_file_ends
                                            \ . (a:direction == 1 ? '' : '|%$')
                                            \ . (a:direction == 0 ? '' : '|%^')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#WBK(visualmode, direction) " {{{
                                " vim's iskeyword style word motion
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let regex_without_file_ends = '\v<|^\S|\s\zs\S|>\zs\S|^$'
                                let regex = l:regex_without_file_ends
                                            \ . (a:direction == 1 ? '' : '|%$')
                                            \ . (a:direction == 0 ? '' : '|%^')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#E(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                call s:EasyMotion('\(.\>\|^$\)', a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#EW(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                " Note: The stopping positions for 'E' and 'gE' differs. Thus, the regex
                                " for direction==2 cannot be the same in both directions. This will be
                                " ignored.
                                let regex_stub = '\v\S(\s|$)'
                                let regex = l:regex_stub
                                            \ . (a:direction == 0 ? '' : '|^$|%^')
                                            \ . (a:direction == 1 ? '' : '|%$')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#EK(visualmode, direction) " {{{
                                " vim's iskeyword style word motion
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                                " Note: The stopping positions for 'e' and 'ge' differs. Thus, the regex
                                " for direction==2 cannot be the same in both directions. This will be
                                " ignored.
                                let regex_stub = '\v.\ze>|\S\ze\s*$|\S\ze\s|\k\zs>\S\ze|\S<'
                                let regex = l:regex_stub
                                            \ . (a:direction == 0 ? '' : '|^$|%^')
                                            \ . (a:direction == 1 ? '' : '|%$')
                                call s:EasyMotion(l:regex, a:direction, a:visualmode ? visualmode() : '', 0)
                            
                            
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- JK Motion ---------------------------
    1              0.000003 function! EasyMotion#JK(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let s:flag.linewise = 1
                            
                                if g:EasyMotion_startofline
                                    call s:EasyMotion('^\(\w\|\s*\zs\|$\)', a:direction, a:visualmode ? visualmode() : '', 0)
                                else
                                    let vcol  = EasyMotion#helper#vcol('.')
                                    let pattern = printf('^.\{-}\zs\(\%%<%dv.\%%>%dv\|$\)', vcol + 1, vcol)
                                    call s:EasyMotion(pattern, a:direction, a:visualmode ? visualmode() : '', 0)
                                endif
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#Sol(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let s:flag.linewise = 1
                                call s:EasyMotion('^\(.\|$\)', a:direction, a:visualmode ? visualmode() : '', '')
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#Eol(visualmode, direction) " {{{
                                let s:flag.linewise = 1
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion('\(\w\|\s*\zs\|.\|^\)$', a:direction, a:visualmode ? visualmode() : '', '')
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Search Motion -----------------------
    1              0.000004 function! EasyMotion#Search(visualmode, direction, respect_direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let search_direction = a:respect_direction ?
                                \   (a:direction == 1 ? v:searchforward : 1-v:searchforward) :
                                \   (a:direction)
                                call s:EasyMotion(@/, search_direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- JumpToAnywhere Motion ---------------
    1              0.000003 function! EasyMotion#JumpToAnywhere(visualmode, direction) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                call s:EasyMotion( g:EasyMotion_re_anywhere, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Line Motion -------------------------
    1              0.000004 function! EasyMotion#SL(num_strokes, visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#S(a:num_strokes, a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#TL(num_strokes, visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#T(a:num_strokes, a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#WBL(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#WBK(a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#EL(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                call EasyMotion#EK(a:visualmode, a:direction)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#LineAnywhere(visualmode, direction) " {{{
                                let s:flag.within_line = 1
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let re = g:EasyMotion_re_line_anywhere
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', 0)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- User Motion -------------------------
    1              0.000034 let s:config = {
                            \   'pattern': '',
                            \   'visualmode': s:FALSE,
                            \   'direction': s:DIRECTION.forward,
                            \   'inclusive': s:FALSE,
                            \   'accept_cursor_pos': s:FALSE,
                            \   'overwin': s:FALSE
                            \ }
                            
    1              0.000008 function! s:default_config() abort
                                let c = copy(s:config)
                                let m = mode(1)
                                let c.inclusive = m ==# 'no' ? s:TRUE : s:FALSE
                                return c
                            endfunction
                            
    1              0.000003 function! EasyMotion#go(...) abort
                                let c = extend(s:default_config(), get(a:, 1, {}))
                                if c.overwin
                                    return EasyMotion#overwin#move(c.pattern)
                                else
                                    let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                    call s:EasyMotion(c.pattern, c.direction, c.visualmode ? visualmode() : '', c.inclusive, c)
                                    return s:EasyMotion_is_cancelled
                                endif
                            endfunction
    1              0.000006 function! EasyMotion#User(pattern, visualmode, direction, inclusive, ...) " {{{
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                let is_inclusive = mode(1) ==# 'no' ? a:inclusive : 0
                                let re = a:pattern
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive, get(a:, 1, {}))
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " -- Repeat Motion -----------------------
    1              0.000008 function! EasyMotion#Repeat(visualmode) " {{{
                                " Repeat previous motion with previous targets
                                if !has_key(s:previous, 'regexp')
                                    call s:Message("Previous targets doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                                let re = s:previous.regexp
                                let direction = s:previous.direction
                                let s:flag.within_line = s:previous.line_flag
                                let s:flag.bd_t = s:previous.bd_t_flag
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " FIXME: is_inclusive value is inappropriate but handling this value is
                                " difficult and priorities is low because this motion maybe used usually
                                " as a 'normal' motion.
                                let is_inclusive = mode(1) ==# 'no' ? 1 : 0
                            
                                call s:EasyMotion(re, direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000003 function! EasyMotion#DotRepeat() " {{{
                                let cnt = v:count1 " avoid overwriting
                            
                                " Repeat previous '.' motion with previous targets and operator
                                if !has_key(s:dot_repeat, 'regexp')
                                    call s:Message("Previous motion doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                            
                                let re = s:dot_repeat.regexp
                                let direction = s:dot_repeat.direction
                                let is_inclusive = s:dot_repeat.is_inclusive
                            
                                for i in range(cnt)
                                    " s:EasyMotion() always call reset s:flag & s:current
                                    let s:flag.dot_repeat = 1
                                    let s:flag.within_line = s:dot_repeat.line_flag
                                    let s:flag.bd_t = s:dot_repeat.bd_t_flag
                                    let s:current.is_operator = 1
                            
                                    let s:flag.count_dot_repeat = (i > 0 ? 1 : 0)
                                    silent call s:EasyMotion(re, direction, 0, is_inclusive)
                                endfor
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
    1              0.000004 function! EasyMotion#NextPrevious(visualmode, direction) " {{{
                                " Move next/previous destination using previous motion regexp
                                let cnt = v:count1 " avoid overwriting
                                if !has_key(s:previous, 'regexp')
                                    call s:Message("Previous targets doesn't exist")
                                    let s:EasyMotion_is_cancelled = 1
                                    return s:EasyMotion_is_cancelled
                                endif
                                let re = s:previous.regexp
                                let search_direction = (a:direction == 1 ? 'b' : '')
                            
                                if g:EasyMotion_move_highlight
                                    call EasyMotion#highlight#attach_autocmd()
                                    call EasyMotion#highlight#add_highlight(re, g:EasyMotion_hl_move)
                                endif
                            
                                if ! empty(a:visualmode)
                                    " FIXME: blink highlight
                                    silent exec 'normal! gv'
                                endif
                            
                                " Mark jump-list
                                if cnt > 1
                                    " Consider Next/Previous motions as jump motion :h jump-motion
                                    " Note: It should add jumplist even if the count isn't given
                                    "       considering vim's default behavior of `n` & `N`, but just
                                    "       I don't want to do it without the count. Should I add a
                                    "       option?
                                    normal! m`
                                endif
                            
                                " Jump
                                " @vimlint(EVL102, 1, l:_)
                                for _ in range(cnt)
                                    keepjumps call searchpos(re, search_direction)
                                endfor
                            
                                normal! zv
                            
                                call EasyMotion#reset()
                                " -- Activate EasyMotion ----------------- {{{
                                let s:EasyMotion_is_active = 1
                                call EasyMotion#attach_active_autocmd() "}}}
                                return s:EasyMotion_is_cancelled
                            endfunction " }}}
                            " }}}
                            " Helper Functions: {{{
                            " -- Message -----------------------------
    1              0.000005 function! s:Message(message) " {{{
                                if g:EasyMotion_verbose
                                    echo 'EasyMotion: ' . a:message
                                else
                                    " Make the current message disappear
                                    echo ''
                                    " redraw
                                endif
                            endfunction " }}}
    1              0.000004 function! s:Prompt(message) " {{{
                                echohl Question
                                echo a:message . ': '
                                echohl None
                            endfunction " }}}
    1              0.000003 function! s:Throw(message) "{{{
                                throw 'EasyMotion: ' . a:message
                            endfunction "}}}
                            
                            " -- Save & Restore values ---------------
    1              0.000003 function! s:SaveValue() "{{{
                                if ! s:current.is_search
                                    call EasyMotion#helper#VarReset('&scrolloff', 0)
                                endif
                                call EasyMotion#helper#VarReset('&modified', 0)
                                call EasyMotion#helper#VarReset('&modifiable', 1)
                                call EasyMotion#helper#VarReset('&readonly', 0)
                                call EasyMotion#helper#VarReset('&spell', 0)
                                call EasyMotion#helper#VarReset('&virtualedit', '')
                                " if &foldmethod !=# 'expr'
                                    call EasyMotion#helper#VarReset('&foldmethod', 'manual')
                                " endif
                            endfunction "}}}
    1              0.000003 function! s:RestoreValue() "{{{
                                call EasyMotion#helper#VarReset('&scrolloff')
                                call EasyMotion#helper#VarReset('&modified')
                                call EasyMotion#helper#VarReset('&modifiable')
                                call EasyMotion#helper#VarReset('&readonly')
                                call EasyMotion#helper#VarReset('&spell')
                                call EasyMotion#helper#VarReset('&virtualedit')
                                " if &foldmethod !=# 'expr'
                                    call EasyMotion#helper#VarReset('&foldmethod')
                                " endif
                            endfunction "}}}
    1              0.000004 function! s:turn_off_hl_error() "{{{
                                let s:error_hl = EasyMotion#highlight#capture('Error')
                                call EasyMotion#highlight#turn_off(s:error_hl)
                                let s:matchparen_hl = EasyMotion#highlight#capture('MatchParen')
                                call EasyMotion#highlight#turn_off(s:matchparen_hl)
                            endfunction "}}}
    1              0.000003 function! s:turn_on_hl_error() "{{{
                                if exists('s:error_hl')
                                    call EasyMotion#highlight#turn_on(s:error_hl)
                                    unlet s:error_hl
                                endif
                            
                                if exists('s:matchparen_hl')
                                    call EasyMotion#highlight#turn_on(s:matchparen_hl)
                                    unlet s:matchparen_hl
                                endif
                            endfunction "}}}
                            
                            " -- Draw --------------------------------
    1              0.000004 function! s:SetLines(lines, key) " {{{
                                for [line_num, line] in a:lines
                                    keepjumps call setline(line_num, line[a:key])
                                endfor
                            endfunction " }}}
                            
                            " -- Get characters from user input ------
    1              0.000004 function! s:GetChar(...) abort "{{{
                                let mode = get(a:, 1, 0)
                                while 1
                                    " Workaround for https://github.com/osyo-manga/vital-over/issues/53
                                    try
                                        let char = call('getchar', a:000)
                                    catch /^Vim:Interrupt$/
                                        let char = 3 " <C-c>
                                    endtry
                                    if char == 27 || char == 3
                                        " Escape or <C-c> key pressed
                                        redraw
                                        call s:Message('Cancelled')
                                        return ''
                                    endif
                                    " Workaround for the <expr> mappings
                                    if string(char) !=# "\x80\xfd`"
                                        return mode == 1 ? !!char
                                        \    : type(char) == type(0) ? nr2char(char) : char
                                    endif
                                endwhile
                            endfunction "}}}
                            
                            " -- Find Motion Helper ------------------
    1              0.000003 function! s:findMotion(num_strokes, direction) "{{{
                                " Find Motion: S,F,T
                                let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " store cursor pos because 'n' key find motion could be jump to offscreen
                                let s:current.original_position = [line('.'), col('.')]
                                let s:current.is_search = a:num_strokes == -1 ? 1: 0
                                let s:flag.regexp = a:num_strokes == -1 ? 1 : 0 " TODO: remove?
                            
                                if g:EasyMotion_add_search_history && a:num_strokes == -1
                                    let s:previous['input'] = @/
                                else
                                    let s:previous['input'] = get(s:previous, 'input', '')
                                endif
                                let input = EasyMotion#command_line#GetInput(
                                                \ a:num_strokes, s:previous.input, a:direction)
                                let s:previous['input'] = input
                            
                                " Check that we have an input char
                                if empty(input)
                                    return ''
                                endif
                            
                                let re = s:convertRegep(input)
                            
                                if g:EasyMotion_add_search_history && a:num_strokes == -1
                                    let history_re = substitute(re, '\\c\|\\C', '', '')
                                    let @/ = history_re "For textobject: 'gn'
                                    call histadd('search', history_re)
                                endif
                            
                                return re
                            endfunction "}}}
    1              0.000004 function! s:convertRegep(input) "{{{
                                " 1. regexp
                                " 2. migemo
                                " 3. smartsign
                                " 4. smartcase
                                let use_migemo = s:should_use_migemo(a:input)
                                let re = use_migemo || s:should_use_regexp() ? a:input : s:escape_regexp_char(a:input)
                            
                                " Convert space to match only start of spaces
                                if re ==# ' '
                                    let re = '\s\+'
                                endif
                            
                                if use_migemo
                                    let re = s:convertMigemo(re)
                                endif
                            
                                if s:should_use_smartsign(a:input)
                                    let r = s:convertSmartsign(a:input)
                                    if use_migemo
                                        let re = re . '\m\|' . r
                                    else
                                        let re = r
                                    endif
                                endif
                            
                                let case_flag = EasyMotion#helper#should_case_sensitive(
                                                    \ a:input, s:current.is_search) ? '\c' : '\C'
                                let re = case_flag . re
                                return re
                            endfunction "}}}
    1              0.000004 function! s:convertMigemo(re) "{{{
                                let re = a:re
                            
                                if len(re) > 1
                                    " System cmigemo
                                    return EasyMotion#cmigemo#getMigemoPattern(re)
                                endif
                            
                                " EasyMotion migemo one key dict
                                if ! has_key(s:migemo_dicts, &l:encoding)
                                    let s:migemo_dicts[&l:encoding] = EasyMotion#helper#load_migemo_dict()
                                endif
                                return get(s:migemo_dicts[&l:encoding], re, a:re)
                            endfunction "}}}
    1              0.000003 function! s:convertSmartsign(chars) "{{{
                                " Convert given chars to smartsign string
                                " Example: 12 -> [1!][2@]
                                "          a] -> a[]}]
                            
                                " Load smartsign dictionary
                                let smart_dict = s:load_smart_dict()
                                " Prepare converted string
                                let converted_str = ''
                                " Get `upper_sign` for each given chars
                                " Split chars into list
                                for char in split(a:chars, '\zs')
                                    let upper_sign = s:get_escaped_group_char(smart_dict, char)
                                    if upper_sign ==# ''
                                        let converted_str .= s:escape_regexp_char(char)
                                    else
                                        " [1!]
                                        let converted_str .= '[' . char . upper_sign . ']'
                                    endif
                                endfor
                                return converted_str
                            endfunction "}}}
    1              0.000005 function! s:get_escaped_group_char(dict, char) "{{{
                                " Get escaped char from given dictionary
                                " return '' if char is not find
                                " Used inside `[]`
                                return escape(get(a:dict, a:char, ''), '^')
                            endfunction "}}}
    1              0.000004 function! s:escape_regexp_char(char) "{{{
                                return escape(a:char, '.$^~\[]*')
                            endfunction "}}}
    1              0.000003 function! s:convertSmartcase(re, char) "{{{
                                let re = a:re
                                if a:char =~# '\U' "nonuppercase
                                    return '\c' . re
                                else "uppercase
                                    return '\C' . re
                                endif
                            endfunction "}}}
    1              0.000003 function! s:should_use_regexp() "{{{
                                return g:EasyMotion_use_regexp == 1 && s:flag.regexp == 1
                            endfunction "}}}
    1              0.000003 function! s:should_use_migemo(char) "{{{
                                if ! g:EasyMotion_use_migemo || match(a:char, '[^!-~]') != -1
                                    return 0
                                endif
                            
                                " TODO: use direction to improve
                                if s:flag.within_line == 1
                                    let first_line = line('.')
                                    let end_line = line('.')
                                else
                                    let first_line = line('w0')
                                    let end_line = line('w$')
                                endif
                            
                                " Skip folded line and check if text include multibyte characters
                                for line in range(first_line, end_line)
                                    if EasyMotion#helper#is_folded(line)
                                        continue
                                    endif
                            
                                    if EasyMotion#helper#include_multibyte_char(getline(line)) == 1
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction "}}}
    1              0.000004 function! s:should_use_smartsign(char) "{{{
                                " Smartsign Dictionary exists?
                                " \A: non-alphabetic character
                                " Do not use smartsign for n-key find search motions
                                if (exists('g:EasyMotion_use_smartsign_us')  ||
                                \   exists('g:EasyMotion_use_smartsign_jp')) &&
                                \  match(a:char, '\A') != -1 &&
                                \ exists('s:current.is_search') && s:current.is_search == 0
                                    return 1
                                else
                                    return 0
                                endif
                            endfunction "}}}
    1              0.000005 function! s:convert_t_regexp(re, direction) "{{{
                                if a:direction == 0 "forward
                                    return '\_.\ze\('.a:re.'\)'
                                elseif a:direction == 1 "backward
                                    return '\('.a:re.'\)\@<=\_.'
                                endif
                            endfunction "}}}
                            
                            " -- Handle Visual Mode ------------------
    1              0.000006 function! s:GetVisualStartPosition(c_pos, v_start, v_end, search_direction) "{{{
                                let vmode = mode(1)
                                if vmode !~# "^[Vv\<C-v>]"
                                    call s:Throw('Unkown visual mode:'.vmode)
                                endif
                            
                                if vmode ==# 'V' "line-wise Visual
                                    " Line-wise Visual {{{
                                    if a:v_start[0] == a:v_end[0]
                                        if a:search_direction == ''
                                            return a:v_start
                                        elseif a:search_direction == 'b'
                                            return a:v_end
                                        else
                                            call s:throw('Unkown search_direction')
                                        endif
                                    else
                                        if a:c_pos[0] == a:v_start[0]
                                            return a:v_end
                                        elseif a:c_pos[0] == a:v_end[0]
                                            return a:v_start
                                        endif
                                    endif
                                    "}}}
                                else
                                    " Character-wise or Block-wise Visual"{{{
                                    if a:c_pos == a:v_start
                                        return a:v_end
                                    elseif a:c_pos == a:v_end
                                        return a:v_start
                                    endif
                            
                                    " virtualedit
                                    if a:c_pos[0] == a:v_start[0]
                                        return a:v_end
                                    elseif a:c_pos[0] == a:v_end[0]
                                        return a:v_start
                                    elseif EasyMotion#helper#is_greater_coords(a:c_pos, a:v_start) == 1
                                        return a:v_end
                                    else
                                        return a:v_start
                                    endif
                                    "}}}
                                endif
                            endfunction "}}}
                            
                            " -- Others ------------------------------
    1              0.000004 function! s:handleEmpty(input, visualmode) "{{{
                                " if empty, reselect and return 1
                                if empty(a:input)
                                    if ! empty(a:visualmode)
                                        silent exec 'normal! gv'
                                    endif
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                    return 1
                                endif
                                return 0
                            endfunction "}}}
    1              0.000003 function! s:load_smart_dict() "{{{
                                if exists('g:EasyMotion_use_smartsign_us')
                                    return g:EasyMotion#sticky_table#us
                                elseif exists('g:EasyMotion_use_smartsign_jp')
                                    return g:EasyMotion#sticky_table#jp
                                else
                                    return {}
                                endif
                            endfunction "}}}
    1              0.000003 function! EasyMotion#attach_active_autocmd() "{{{
                                " Reference: https://github.com/justinmk/vim-sneak
                                augroup plugin-easymotion-active
                                    autocmd!
                                    autocmd InsertEnter,WinLeave,BufLeave <buffer>
                                        \ let s:EasyMotion_is_active = 0
                                        \  | autocmd! plugin-easymotion-active * <buffer>
                                    autocmd CursorMoved <buffer>
                                        \ autocmd plugin-easymotion-active CursorMoved <buffer>
                                        \ let s:EasyMotion_is_active = 0
                                        \  | autocmd! plugin-easymotion-active * <buffer>
                                augroup END
                            endfunction "}}}
    1              0.000003 function! EasyMotion#is_active() "{{{
                                return s:EasyMotion_is_active
                            endfunction "}}}
    1              0.000003 function! EasyMotion#activate(is_visual) "{{{
                                let s:EasyMotion_is_active = 1
                                call EasyMotion#attach_active_autocmd()
                                call EasyMotion#highlight#add_highlight(s:previous.regexp,
                                                                      \ g:EasyMotion_hl_move)
                                call EasyMotion#highlight#attach_autocmd()
                                if a:is_visual == 1
                                    normal! gv
                                endif
                            endfunction "}}}
    1              0.000008 function! s:restore_cursor_state(visualmode) "{{{
                                " -- Restore original cursor position/selection
                                if ! empty(a:visualmode)
                                    silent exec 'normal! gv'
                                    keepjumps call cursor(s:current.cursor_position)
                                else
                                    keepjumps call cursor(s:current.original_position)
                                endif
                            endfunction " }}}
                            " Grouping Algorithms: {{{
    1              0.000014 let s:grouping_algorithms = {
                            \   1: 'SCTree'
                            \ , 2: 'Original'
                            \ }
                            " -- Single-key/closest target priority tree {{{
                            " This algorithm tries to assign one-key jumps to all the targets closest to the cursor.
                            " It works recursively and will work correctly with as few keys as two.
    1              0.000004 function! s:GroupingAlgorithmSCTree(targets, keys) "{{{
                                " Prepare variables for working
                                let targets_len = len(a:targets)
                                let keys_len = len(a:keys)
                            
                                let groups = {}
                            
                                let keys = reverse(copy(a:keys))
                            
                                " Semi-recursively count targets {{{
                                    " We need to know exactly how many child nodes (targets) this branch will have
                                    " in order to pass the correct amount of targets to the recursive function.
                            
                                    " Prepare sorted target count list {{{
                                        " This is horrible, I know. But dicts aren't sorted in vim, so we need to
                                        " work around that. That is done by having one sorted list with key counts,
                                        " and a dict which connects the key with the keys_count list.
                            
                                        let keys_count = []
                                        let keys_count_keys = {}
                            
                                        let i = 0
                                        for key in keys
                                            call add(keys_count, 0)
                            
                                            let keys_count_keys[key] = i
                            
                                            let i += 1
                                        endfor
                                    " }}}
                            
                                    let targets_left = targets_len
                                    let level = 0
                                    let i = 0
                            
                                    while targets_left > 0
                                        " Calculate the amount of child nodes based on the current level
                                        let childs_len = (level == 0 ? 1 : (keys_len - 1) )
                            
                                        for key in keys
                                            " Add child node count to the keys_count array
                                            let keys_count[keys_count_keys[key]] += childs_len
                            
                                            " Subtract the child node count
                                            let targets_left -= childs_len
                            
                                            if targets_left <= 0
                                                " Subtract the targets left if we added too many too
                                                " many child nodes to the key count
                                                let keys_count[keys_count_keys[key]] += targets_left
                            
                                                break
                                            endif
                            
                                            let i += 1
                                        endfor
                            
                                        let level += 1
                                    endwhile
                                " }}}
                                " Create group tree {{{
                                    let i = 0
                                    let key = 0
                            
                                    call reverse(keys_count)
                            
                                    for key_count in keys_count
                                        if key_count > 1
                                            " We need to create a subgroup
                                            " Recurse one level deeper
                                            let groups[a:keys[key]] = s:GroupingAlgorithmSCTree(a:targets[i : i + key_count - 1], a:keys)
                                        elseif key_count == 1
                                            " Assign single target key
                                            let groups[a:keys[key]] = a:targets[i]
                                        else
                                            " No target
                                            continue
                                        endif
                            
                                        let key += 1
                                        let i += key_count
                                    endfor
                                " }}}
                            
                                " Finally!
                                return groups
                            endfunction "}}}
                            " }}}
                            " -- Original ---------------------------- {{{
    1              0.000004 function! s:GroupingAlgorithmOriginal(targets, keys)
                                " Split targets into groups (1 level)
                                let targets_len = len(a:targets)
                                " let keys_len = len(a:keys)
                            
                                let groups = {}
                            
                                let i = 0
                                let root_group = 0
                                try
                                    while root_group < targets_len
                                        let groups[a:keys[root_group]] = {}
                            
                                        for key in a:keys
                                            let groups[a:keys[root_group]][key] = a:targets[i]
                            
                                            let i += 1
                                        endfor
                            
                                        let root_group += 1
                                    endwhile
                                catch | endtry
                            
                                " Flatten the group array
                                if len(groups) == 1
                                    let groups = groups[a:keys[0]]
                                endif
                            
                                return groups
                            endfunction
                            " }}}
                            
                            " -- Coord/key dictionary creation ------- {{{
    1              0.000004 function! s:CreateCoordKeyDict(groups, ...)
                                " Dict structure:
                                " 1,2 : a
                                " 2,3 : b
                                let sort_list = []
                                let coord_keys = {}
                                let group_key = a:0 == 1 ? a:1 : ''
                            
                                for [key, item] in items(a:groups)
                                    let key = group_key . key
                                    "let key = ( ! empty(group_key) ? group_key : key)
                            
                                    if type(item) == type([]) " List
                                        " Destination coords
                            
                                        " The key needs to be zero-padded in order to
                                        " sort correctly
                                        let dict_key = printf('%05d,%05d', item[0], item[1])
                                        let coord_keys[dict_key] = key
                            
                                        " We need a sorting list to loop correctly in
                                        " PromptUser, dicts are unsorted
                                        call add(sort_list, dict_key)
                                    else
                                        " Item is a dict (has children)
                                        let coord_key_dict = s:CreateCoordKeyDict(item, key)
                            
                                        " Make sure to extend both the sort list and the
                                        " coord key dict
                                        call extend(sort_list, coord_key_dict[0])
                                        call extend(coord_keys, coord_key_dict[1])
                                    endif
                            
                                    unlet item
                                endfor
                            
                                return [sort_list, coord_keys]
                            endfunction
                            " }}}
                            " }}}
                            "}}}
                            " Core Functions: {{{
    1              0.000004 function! s:PromptUser(groups) "{{{
                                " Recursive
                                let group_values = values(a:groups)
                            
                                " -- If only one possible match, jump directly to it {{{
                                if len(group_values) == 1
                                    if mode(1) ==# 'no'
                                        " Consider jump to first match
                                        " NOTE: matchstr() handles multibyte characters.
                                        let s:dot_repeat['target'] = matchstr(g:EasyMotion_keys, '^.')
                                    endif
                                    redraw
                                    return group_values[0]
                                endif
                                " }}}
                            
                                " -- Prepare marker lines ---------------- {{{
                                let lines = {}
                            
                                let coord_key_dict = s:CreateCoordKeyDict(a:groups)
                            
                                let prev_col_num = 0
                                for dict_key in sort(coord_key_dict[0])
                                    " NOTE: {{{
                                    " let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                                    " Perform <Plug>(easymotion-w)
                                    "
                                    " lines[line_num]['orig']:
                                    "   Lorem ipsum dolor sit amet consectetur adipisicing
                                    "
                                    " {target_char}:
                                    "   {L}orem {i}psum {d}olor {s}it {a}met {c}onsectetur {a}dipisicing
                                    "
                                    " lines[line_num]['marker'], {marker_chars}:
                                    "   {A}orem {B}psum {C}olor {D}it {E}met {F}onsectetur {G}dipisicing
                                    "   2-key-combo: {marker_chars} could be 1 or 2 chars like {AB}
                                    "
                                    " }}}
                            
                                    " Prepare original line and marker line {{{
                                    let [line_num, col_num] = split(dict_key, ',')
                            
                                    let line_num = str2nr(line_num)
                                    let col_num = str2nr(col_num)
                                    if ! has_key(lines, line_num)
                                        let current_line = getline(line_num)
                                        let lines[line_num] = {
                                            \ 'orig': current_line,
                                            \ 'marker': current_line,
                                            \ 'mb_compensation': 0,
                                            \ }
                                        " mb_compensation -> multibyte compensation
                                        let prev_col_num = 0
                                    endif "}}}
                            
                                    " Multibyte Compensation: {{{
                                    " Solve multibyte issues by matching the byte column
                                    " number instead of the visual column
                                    " Compensate for byte difference between marker
                                    " character and target character
                                    "
                                    " This has to be done in order to match the correct
                                    " column; \%c matches the byte column and not display
                                    " column.
                                    let col_num = max([prev_col_num + 1,
                                                    \  col_num - lines[line_num]['mb_compensation']])
                                    let prev_col_num = col_num
                                    "}}}
                            
                                    " Prepare marker characters {{{
                                    let marker_chars = coord_key_dict[1][dict_key]
                                    let marker_chars_len = EasyMotion#helper#strchars(marker_chars)
                                    "}}}
                            
                                    " Replace {target} with {marker} & Highlight {{{
                                    let col_add = 0 " Column add byte length
                                    " Disable two-key-combo feature?
                                    let marker_max_length = g:EasyMotion_disable_two_key_combo == 1
                                                            \ ? 1 : 2
                                    for i in range(min([marker_chars_len, marker_max_length]))
                                        let marker_char = split(marker_chars, '\zs')[i]
                                        " EOL {{{
                                        if strlen(lines[line_num]['marker']) < col_num + col_add
                                            " Append marker chars if target is EOL
                                            let lines[line_num]['marker'] .= ' '
                                        endif "}}}
                            
                                        let target_col_regexp = '\%' . (col_num + col_add) . 'c.'
                                        let target_char = matchstr(lines[line_num]['marker'],
                                                                  \ target_col_regexp)
                                        let space_len = strdisplaywidth(target_char)
                                                    \ - strdisplaywidth(marker_char)
                                        " Substitute marker character
                                        let substitute_expr = marker_char . repeat(' ', space_len)
                            
                                        let lines[line_num]['marker'] = substitute(
                                            \ lines[line_num]['marker'],
                                            \ target_col_regexp,
                                            \ escape(substitute_expr,'&'),
                                            \ '')
                            
                                        " Highlight targets {{{
                                        let _hl_group =
                                        \   (marker_chars_len == 1) ? g:EasyMotion_hl_group_target
                                        \   : (i == 0) ? g:EasyMotion_hl2_first_group_target
                                        \   : g:EasyMotion_hl2_second_group_target
                            
                                        if exists('*matchaddpos')
                                            call EasyMotion#highlight#add_pos_highlight(
                                                        \ line_num, col_num + col_add, _hl_group)
                                        else
                                            call EasyMotion#highlight#add_highlight(
                                                \ '\%' . line_num . 'l' . target_col_regexp,
                                                \ _hl_group)
                                        endif
                                        "}}}
                            
                                        " Add marker/target length difference for multibyte compensation
                                        let lines[line_num]['mb_compensation'] +=
                                            \ strlen(target_char) - strlen(substitute_expr)
                                        " Shift column
                                        let col_add += strlen(marker_char)
                                    endfor
                                    "}}}
                                endfor
                            
                                let lines_items = items(lines)
                                " }}}
                            
                                " -- Put labels on targets & Get User Input & Restore all {{{
                                " Save undo tree
                                let undo_lock = EasyMotion#undo#save()
                                try
                                    " Set lines with markers {{{
                                    call s:SetLines(lines_items, 'marker')
                                    redraw "}}}
                            
                                    " Get target character {{{
                                    call s:Prompt('Target key')
                                    let char = s:GetChar()
                                    "}}}
                            
                                    " Convert uppercase {{{
                                    if g:EasyMotion_use_upper == 1 && match(g:EasyMotion_keys, '\l') == -1
                                        let char = toupper(char)
                                    endif "}}}
                            
                                    " Jump first target when Enter or Space key is pressed "{{{
                                    if (char ==# "\<CR>" && g:EasyMotion_enter_jump_first == 1) ||
                                    \  (char ==# "\<Space>" && g:EasyMotion_space_jump_first == 1)
                                        " NOTE: matchstr() is multibyte aware.
                                        let char = matchstr(g:EasyMotion_keys, '^.')
                                    endif "}}}
                            
                                    " For dot repeat {{{
                                    if mode(1) ==# 'no'
                                        " Store previous target when operator pending mode
                                        if s:current.dot_prompt_user_cnt == 0
                                            " Store
                                            let s:dot_repeat['target'] = char
                                        else
                                            " Append target chars
                                            let s:dot_repeat['target'] .= char
                                        endif
                                    endif "}}}
                            
                                finally
                                    " Restore original lines
                                    call s:SetLines(lines_items, 'orig')
                            
                                    " Un-highlight targets {{{
                                    call EasyMotion#highlight#delete_highlight(
                                        \ g:EasyMotion_hl_group_target,
                                        \ g:EasyMotion_hl2_first_group_target,
                                        \ g:EasyMotion_hl2_second_group_target,
                                        \ )
                                    " }}}
                            
                                    " Restore undo tree
                                    call undo_lock.restore()
                            
                                    redraw
                                endtry "}}}
                            
                                " -- Check if we have an input char ------ {{{
                                if empty(char)
                                    call s:Throw('Cancelled')
                                endif
                                " }}}
                                " -- Check if the input char is valid ---- {{{
                                if ! has_key(a:groups, char)
                                    call s:Throw('Invalid target')
                                endif
                                " }}}
                            
                                let target = a:groups[char]
                            
                                if type(target) == type([])
                                    " Return target coordinates
                                    return target
                                else
                                    " Prompt for new target character
                                    let s:current.dot_prompt_user_cnt += 1
                                    return s:PromptUser(target)
                                endif
                            endfunction "}}}
    1              0.000005 function! s:DotPromptUser(groups) "{{{
                                " Get char from previous target
                                let char = s:dot_repeat.target[s:current.dot_repeat_target_cnt]
                                " For dot repeat target chars
                                let s:current.dot_repeat_target_cnt += 1
                            
                                let target = a:groups[char]
                            
                                if type(target) == type([])
                                    " Return target coordinates
                                    return target
                                else
                                    " Prompt for new target character
                                    return s:PromptUser(target)
                                endif
                            endfunction "}}}
                            
    1              0.000005 function! s:EasyMotion(regexp, direction, visualmode, is_inclusive, ...) " {{{
                                let config = extend(s:default_config(), get(a:, 1, {}))
                                " Store s:current original_position & cursor_position {{{
                                " current cursor pos.
                                let s:current.cursor_position = [line('.'), col('.')]
                                " original start position.  This value could be changed later in visual
                                " mode
                                let s:current.original_position =
                                    \ get(s:current, 'original_position', s:current.cursor_position)
                                "}}}
                            
                                let win_first_line = line('w0') " visible first line num
                                let win_last_line  = line('w$') " visible last line num
                            
                                " Store the target positions list
                                " e.g. targets = [ [line, col], [line2, col2], ...]
                                let targets = []
                            
                                " Store info for Repeat motion {{{
                                if s:flag.dot_repeat != 1
                                    " Store Regular Expression
                                    let s:previous['regexp'] = a:regexp
                                    let s:previous['direction'] = a:direction
                                    let s:previous['operator'] = v:operator
                            
                                    " Note: 'is_inclusive' value could be changed later when
                                    " bi-directional find motion depend on 'true' direction the cursor
                                    " will move.
                                    let s:previous['is_inclusive'] = a:is_inclusive
                            
                                    " For special motion flag
                                    let s:previous['line_flag'] = s:flag.within_line
                                    let s:previous['bd_t_flag'] = s:flag.bd_t " bi-directional t motion
                                endif "}}}
                            
                                " To avoid side effect of overwriting buffer for tpope/repeat
                                " store current b:changedtick. Use this value later
                                let s:current.changedtick = b:changedtick
                            
                                try
                                    " -- Reset properties -------------------- {{{
                                    " Save original value and set new value
                                    call s:SaveValue()
                                    call s:turn_off_hl_error()
                                    " }}}
                                    " Setup searchpos args {{{
                                    let search_direction = (a:direction == 1 ? 'b' : '')
                                    let search_stopline = a:direction == 1 ? win_first_line : win_last_line
                            
                                    if s:flag.within_line == 1
                                        let search_stopline = s:current.original_position[0]
                                    endif
                                    "}}}
                            
                                    " Handle visual mode {{{
                                    if ! empty(a:visualmode)
                                        " Decide at where visual mode start {{{
                                        normal! gv
                                        let v_start = [line("'<"),col("'<")] " visual_start_position
                                        let v_end   = [line("'>"),col("'>")] " visual_end_position
                            
                                        let v_original_pos = s:GetVisualStartPosition(
                                            \ s:current.cursor_position, v_start, v_end, search_direction)
                                        "}}}
                            
                                        " Reselect visual text {{{
                                        keepjumps call cursor(v_original_pos)
                                        exec "normal! " . a:visualmode
                                        keepjumps call cursor(s:current.cursor_position)
                                        "}}}
                                        " Update s:current.original_position
                                        " overwrite original start position
                                        let s:current.original_position = v_original_pos
                                    endif "}}}
                            
                                    " Handle bi-directional t motion {{{
                                    if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 0) "forward
                                    else
                                        let regexp = a:regexp
                                    endif
                                    "}}}
                            
                                    " Handle dot repeat with count
                                    if s:flag.count_dot_repeat
                                        let cursor_char = EasyMotion#helper#get_char_by_coord(s:current.cursor_position)
                                        if cursor_char =~# regexp
                                            call add(targets, s:current.cursor_position)
                                        endif
                                    endif
                            
                                    " Construct match dict {{{
                                    " Note: searchpos() has side effect which jump cursor position.
                                    "       You can disable this side effect by add 'n' flags,
                                    "       but in this case, it's better to allows jump side effect
                                    "       to gathering matched targets coordinates.
                                    let pos = searchpos(regexp, search_direction . (config.accept_cursor_pos ? 'c' : ''), search_stopline)
                                    while 1
                                        " Reached end of search range
                                        if pos == [0, 0]
                                            break
                                        endif
                            
                                        " Skip folded lines {{{
                                        if EasyMotion#helper#is_folded(pos[0])
                                            if search_direction ==# 'b'
                                                " FIXME: Hmm... I should use filter()
                                                " keepjumps call cursor(foldclosed(pos[0]), 0)
                                            else
                                                keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                            endif
                                        else
                                            call add(targets, pos)
                                        endif
                                        "}}}
                                        let pos = searchpos(regexp, search_direction, search_stopline)
                                    endwhile
                                    "}}}
                            
                                    " Handle bidirection "{{{
                                    " For bi-directional t motion {{{
                                    if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 1) "backward
                                    endif
                                    "}}}
                                    " Reconstruct match dict
                                    if a:direction == 2
                                        " Backward
                            
                                        " Jump back cursor_position
                                        keepjumps call cursor(s:current.cursor_position[0],
                                                            \ s:current.cursor_position[1])
                            
                                        let targets2 = []
                                        if s:flag.within_line == 0
                                            let search_stopline = win_first_line
                                        else
                                            let search_stopline = s:current.cursor_position[0]
                                        endif
                                        while 1
                                            " TODO: refactoring
                                            let pos = searchpos(regexp, 'b', search_stopline)
                                            " Reached end of search range
                                            if pos == [0, 0]
                                                break
                                            endif
                            
                                            " Skip folded lines {{{
                                            if EasyMotion#helper#is_folded(pos[0])
                                                " keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                                continue
                                            endif
                                            "}}}
                            
                                            call add(targets2, pos)
                                        endwhile
                                        " Merge match target dict"{{{
                                        let t1 = 0 " forward
                                        let t2 = 0 " backward
                                        let targets3 = []
                                        while t1 < len(targets) || t2 < len(targets2)
                                            " Forward -> Backward -> F -> B -> ...
                                            if t1 < len(targets)
                                                call add(targets3, targets[t1])
                                                let t1 += 1
                                            endif
                                            if t2 < len(targets2)
                                                call add(targets3, targets2[t2])
                                                let t2 += 1
                                            endif
                                        endwhile
                                        let targets = targets3
                                        "}}}
                                    endif
                                    "}}}
                                    " Handle no match"{{{
                                    let targets_len = len(targets)
                                    if targets_len == 0
                                        call s:Throw('No matches')
                                    endif
                                    "}}}
                            
                                    " Attach specific key as marker to gathered matched coordinates
                                    let GroupingFn = function('s:GroupingAlgorithm' . s:grouping_algorithms[g:EasyMotion_grouping])
                                    let groups = GroupingFn(targets, split(g:EasyMotion_keys, '\zs'))
                            
                                    " -- Shade inactive source --------------- {{{
                                    if g:EasyMotion_do_shade && targets_len != 1 && s:flag.dot_repeat != 1
                                        if a:direction == 1 " Backward
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '^.*\%#'
                                                            \ : '\%'. win_first_line .'l\_.*\%#'
                                        elseif a:direction == 0 " Forward
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '\%#.*$'
                                                            \ : '\%#\_.*\%'. win_last_line .'l'
                                        else " Both directions
                                            let shade_hl_re = s:flag.within_line
                                                            \ ? '^.*\%#.*$'
                                                            \ : '\_.*'
                                        endif
                            
                                        call EasyMotion#highlight#add_highlight(
                                            \ shade_hl_re, g:EasyMotion_hl_group_shade)
                                        if g:EasyMotion_cursor_highlight
                                            let cursor_hl_re = '\%#'
                                            call EasyMotion#highlight#add_highlight(cursor_hl_re,
                                                \ g:EasyMotion_hl_inc_cursor)
                                        endif
                                    endif
                                    " }}}
                            
                                    " -- Jump back before prompt for visual scroll {{{
                                    " Because searchpos() change current cursor position and
                                    " if you just use cursor(s:current.cursor_position) to jump back,
                                    " current line will become middle of line window
                                    if ! empty(a:visualmode)
                                        keepjumps call winrestview({'lnum' : s:current.cursor_position[0], 'topline' : win_first_line})
                                    else
                                        " for adjusting cursorline
                                        keepjumps call cursor(s:current.cursor_position)
                                    endif
                                    "}}}
                            
                                    " -- Prompt user for target group/character {{{
                                    if s:flag.dot_repeat != 1
                                        let coords = s:PromptUser(groups)
                                    else
                                        let coords = s:DotPromptUser(groups)
                                    endif
                                    "}}}
                            
                                    " -- Update cursor position -------------- {{{
                                    " First, jump back cursor to original position
                                    keepjumps call cursor(s:current.original_position)
                            
                                    " Consider EasyMotion as jump motion :h jump-motion
                                    normal! m`
                            
                                    " Update selection for visual mode {{{
                                    if ! empty(a:visualmode)
                                        exec 'normal! ' . a:visualmode
                                    endif
                                    " }}}
                            
                                    " For bi-directional motion, checking again whether the motion is
                                    " inclusive is necessary. This value will might be updated later
                                    let is_inclusive_check = a:is_inclusive
                                    " For bi-directional motion, store 'true' direction for dot repeat
                                    " to handling inclusive/exclusive motion
                                    if a:direction == 2
                                        let true_direction =
                                            \ EasyMotion#helper#is_greater_coords(
                                            \   s:current.original_position, coords) > 0 ?
                                            \ 0 : 1
                                            " forward : backward
                                    else
                                        let true_direction = a:direction
                                    endif
                            
                                    if s:flag.dot_repeat == 1
                                        " support dot repeat {{{
                                        " Use visual mode to emulate dot repeat
                                        normal! v
                            
                                        " Deal with exclusive {{{
                                        if s:dot_repeat.is_inclusive == 0
                                            " exclusive
                                            if s:dot_repeat.true_direction == 0 "Forward
                                                let coords[1] -= 1
                                            elseif s:dot_repeat.true_direction == 1 "Backward
                                                " Shift visual selection to left by making cursor one key
                                                " left.
                                                normal! hoh
                                            endif
                                        endif "}}}
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " Execute previous operator
                                        let cmd = s:dot_repeat.operator
                                        if s:dot_repeat.operator ==# 'c'
                                            let cmd .= getreg('.')
                                        endif
                                        exec 'normal! ' . cmd
                                        "}}}
                                    else
                                        " Handle inclusive & exclusive {{{
                                        " Overwrite inclusive flag for special case {{{
                                        if s:flag.find_bd == 1 && true_direction == 1
                                            " Note: For bi-directional find motion s(f) & t
                                            " If true_direction is backward, the motion is 'exclusive'
                                            let is_inclusive_check = 0 " overwrite
                                            let s:previous.is_inclusive = 0 " overwrite
                                        endif "}}}
                                        if is_inclusive_check
                                            " Note: {{{
                                            " Inclusive motion requires that we eat one more
                                            " character to the right by forcing the motion to inclusive
                                            " if we're using a forward motion because
                                            " > :h exclusive
                                            " > Note that when using ':' any motion becomes characterwise
                                            " > exclusive.
                                            " and EasyMotion use ':'
                                            " See: h: o_v }}}
                                            normal! v
                                        endif " }}}
                            
                                        if s:current.is_operator && s:flag.linewise
                                            " TODO: Is there better solution?
                                            " Maike it linewise
                                            normal! V
                                        endif
                            
                                        " Adjust screen especially for visual scroll & offscreen search {{{
                                        " Otherwise, cursor line will move middle line of window
                                        keepjumps call winrestview({'lnum' : win_first_line, 'topline' : win_first_line})
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " To avoid side effect of overwriting buffer {{{
                                        " for tpope/vim-repeat
                                        " See: :h b:changedtick
                                        if exists('g:repeat_tick')
                                            if g:repeat_tick == s:current.changedtick
                                                let g:repeat_tick = b:changedtick
                                            endif
                                        endif "}}}
                                    endif
                            
                                    " Set tpope/vim-repeat {{{
                                    if s:current.is_operator == 1 &&
                                            \ !(v:operator ==# 'y' && match(&cpo, 'y') == -1)
                                        " Store previous info for dot repeat {{{
                                        let s:dot_repeat.regexp = a:regexp
                                        let s:dot_repeat.direction = a:direction
                                        let s:dot_repeat.line_flag = s:flag.within_line
                                        let s:dot_repeat.is_inclusive = is_inclusive_check
                                        let s:dot_repeat.operator = v:operator
                                        let s:dot_repeat.bd_t_flag = s:flag.bd_t " Bidirectional t motion
                                        let s:dot_repeat.true_direction = true_direction " Check inclusive
                                        "}}}
                                        silent! call repeat#set("\<Plug>(easymotion-dotrepeat)")
                                    endif "}}}
                            
                                    " Highlight all the matches by n-key find motions {{{
                                    if s:current.is_search == 1 && s:current.is_operator == 0 && g:EasyMotion_add_search_history
                                        " It seems let &hlsearch=&hlsearch doesn't work when called
                                        " in script, so use :h feedkeys() instead.
                                        " Ref: :h v:hlsearch
                                        " FIXME: doesn't work with `c` operator
                                        call EasyMotion#helper#silent_feedkeys(
                                                                \ ":let &hlsearch=&hlsearch\<CR>",
                                                                \ 'hlsearch', 'n')
                                    endif "}}}
                            
                                    call s:Message('Jumping to [' . coords[0] . ', ' . coords[1] . ']')
                                    let s:EasyMotion_is_cancelled = 0 " Success
                                    "}}}
                                catch /^EasyMotion:.*/
                                    redraw
                            
                                    " Show exception message
                                    " The verbose option will take precedence
                                    if g:EasyMotion_verbose == 1 && g:EasyMotion_ignore_exception != 1
                                        echo v:exception
                                    endif
                            
                                    let s:previous['regexp'] = a:regexp
                                    " -- Activate EasyMotion ----------------- {{{
                                    let s:EasyMotion_is_active = 1
                                    call EasyMotion#attach_active_autocmd() "}}}
                            
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                catch
                                    call s:Message(v:exception . ' : ' . v:throwpoint)
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                finally
                                    " -- Restore properties ------------------ {{{
                                    call s:RestoreValue()
                                    call s:turn_on_hl_error()
                                    call EasyMotion#reset()
                                    " }}}
                                    " -- Remove shading ---------------------- {{{
                                    call EasyMotion#highlight#delete_highlight()
                                    " }}}
                            
                                    if s:EasyMotion_is_cancelled == 0 " Success
                                        " -- Landing Highlight ------------------- {{{
                                        if g:EasyMotion_landing_highlight
                                            call EasyMotion#highlight#add_highlight(a:regexp,
                                                                                  \ g:EasyMotion_hl_move)
                                            call EasyMotion#highlight#attach_autocmd()
                                        endif "}}}
                                        " -- Activate EasyMotion ----------------- {{{
                                        let s:EasyMotion_is_active = 1
                                        call EasyMotion#attach_active_autocmd() "}}}
                                    endif
                                endtry
                            endfunction " }}}
                            "}}}
                            " }}}
                            
    1   0.003718   0.000026 call EasyMotion#init()
                            " Restore 'cpoptions' {{{
    1   0.000014   0.000011 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/EasyMotion/highlight.vim
Sourced 1 time
Total time:   0.002412
 Self time:   0.001255

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: highlight.vim
                            " AUTHOR: haya14busa
                            " Reference: https://github.com/t9md/vim-smalls
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000006 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000013 let s:save_cpo = &cpo
    1   0.000031   0.000017 set cpo&vim
                            " }}}
                            
    1              0.000006 function! EasyMotion#highlight#load()
                               "load
                            endfunction
                            
                            " -- Default highlighting ---------------- {{{
    1              0.000020 let g:EasyMotion_hl_group_target         = get(g:,
                                \ 'EasyMotion_hl_group_target', 'EasyMotionTarget')
    1              0.000017 let g:EasyMotion_hl2_first_group_target  = get(g:,
                                \ 'EasyMotion_hl2_first_group_target', 'EasyMotionTarget2First')
    1              0.000012 let g:EasyMotion_hl2_second_group_target = get(g:,
                                \ 'EasyMotion_hl2_second_group_target', 'EasyMotionTarget2Second')
    1              0.000010 let g:EasyMotion_hl_group_shade          = get(g:,
                                \ 'EasyMotion_hl_group_shade', 'EasyMotionShade')
                            
    1              0.000010 let g:EasyMotion_hl_inc_search     = get(g:,
                                \ 'EasyMotion_hl_inc_search', 'EasyMotionIncSearch')
    1              0.000009 let g:EasyMotion_hl_inc_cursor     = get(g:,
                                \ 'EasyMotion_hl_inc_cursor', 'EasyMotionIncCursor')
    1              0.000009 let g:EasyMotion_hl_move           = get(g:,
                                \ 'EasyMotion_hl_move', 'EasyMotionMoveHL')
                            
    1              0.000021 let s:target_hl_defaults = {
                                \   'gui'     : ['NONE', '#ff0000' , 'bold']
                                \ , 'cterm256': ['NONE', '196'     , 'bold']
                                \ , 'cterm'   : ['NONE', 'red'     , 'bold']
                                \ }
                            
    1              0.000017 let s:target_hl2_first_defaults = {
                                \   'gui'     : ['NONE', '#ffb400' , 'bold']
                                \ , 'cterm256': ['NONE', '11'      , 'bold']
                                \ , 'cterm'   : ['NONE', 'yellow'  , 'bold']
                                \ }
                            
    1              0.000022 let s:target_hl2_second_defaults = {
                                \   'gui'     : ['NONE', '#b98300' , 'bold']
                                \ , 'cterm256': ['NONE', '3'       , 'bold']
                                \ , 'cterm'   : ['NONE', 'yellow'  , 'bold']
                                \ }
                            
    1              0.000020 let s:shade_hl_defaults = {
                                \   'gui'     : ['NONE', '#777777' , 'NONE']
                                \ , 'cterm256': ['NONE', '242'     , 'NONE']
                                \ , 'cterm'   : ['NONE', 'grey'    , 'NONE']
                                \ }
                            
    1              0.000016 let s:shade_hl_line_defaults = {
                                \   'gui'     : ['red' , '#FFFFFF' , 'NONE']
                                \ , 'cterm256': ['red' , '242'     , 'NONE']
                                \ , 'cterm'   : ['red' , 'grey'    , 'NONE']
                                \ }
                            
    1              0.000015 let s:target_hl_inc = {
                                \   'gui'     : ['NONE', '#7fbf00' , 'bold']
                                \ , 'cterm256': ['NONE', '40'   , 'bold']
                                \ , 'cterm'   : ['NONE', 'green'   , 'bold']
                                \ }
    1              0.000017 let s:target_hl_inc_cursor = {
                                \   'gui'     : ['#ACDBDA', '#121813' , 'bold']
                                \ , 'cterm256': ['cyan'   , '232'   , 'bold']
                                \ , 'cterm'   : ['cyan'   , 'black'   , 'bold']
                                \ }
    1              0.000022 let s:target_hl_move = {
                                \   'gui'     : ['#7fbf00', '#121813' , 'bold']
                                \ , 'cterm256': ['green'  , '15'   , 'bold']
                                \ , 'cterm'   : ['green'  , 'white'   , 'bold']
                                \ }
                            " }}}
    1              0.000005 function! EasyMotion#highlight#InitHL(group, colors) " {{{
                                let group_default = a:group . 'Default'
                            
                                " Prepare highlighting variables
                                let guihl = printf('guibg=%s guifg=%s gui=%s', a:colors.gui[0], a:colors.gui[1], a:colors.gui[2])
                                let ctermhl = &t_Co == 256
                                    \ ? printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm256[0], a:colors.cterm256[1], a:colors.cterm256[2])
                                    \ : printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm[0], a:colors.cterm[1], a:colors.cterm[2])
                            
                                " Create default highlighting group
                                execute printf('hi default %s %s %s', group_default, guihl, ctermhl)
                            
                                " Check if the hl group exists
                                if hlexists(a:group)
                                    redir => hlstatus | exec 'silent hi ' . a:group | redir END
                            
                                    " Return if the group isn't cleared
                                    if hlstatus !~ 'cleared'
                                        return
                                    endif
                                endif
                            
                                " No colors are defined for this group, link to defaults
                                execute printf('hi default link %s %s', a:group, group_default)
                            endfunction " }}}
    1              0.000004 function! EasyMotion#highlight#init() "{{{
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_target, s:target_hl_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_first_group_target, s:target_hl2_first_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_second_group_target, s:target_hl2_second_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_shade,  s:shade_hl_defaults)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_search, s:target_hl_inc)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_cursor, s:target_hl_inc_cursor)
                                call EasyMotion#highlight#InitHL(g:EasyMotion_hl_move, s:target_hl_move)
                                if exists(':CSApprox') == 2 && g:EasyMotion_force_csapprox
                                    "TODO: better solution or remove completly
                                    CSApprox!
                                endif
                            endfunction "}}}
                            
                            " Reset highlighting after loading a new color scheme {{{
    1              0.000011 augroup EasyMotionInitHL
    1              0.000353     autocmd!
    1              0.000022     autocmd ColorScheme * call EasyMotion#highlight#init()
    1              0.000003 augroup end
                            " }}}
                            
    1   0.001168   0.000046 call EasyMotion#highlight#init()
                            " Init: {{{
    1              0.000005 let s:h = {}
    1              0.000005 let s:h.ids = {}
    1              0.000038 let s:priorities = {
                                \  g:EasyMotion_hl_group_target : 100,
                                \  g:EasyMotion_hl2_first_group_target : 100,
                                \  g:EasyMotion_hl2_second_group_target : 100,
                                \  g:EasyMotion_hl_group_shade : 0,
                                \  g:EasyMotion_hl_inc_search : 1,
                                \  g:EasyMotion_hl_inc_cursor : 2,
                                \  g:EasyMotion_hl_move : 0,
                                \ }
    8              0.000034 for s:group in keys(s:priorities)
    7              0.000035     let s:h.ids[s:group] = []
    7              0.000016 endfor
    1              0.000005 unlet s:group
                            "}}}
                            
    1              0.000005 function! EasyMotion#highlight#delete_highlight(...) "{{{
                                let groups = !empty(a:000) ? a:000 : keys(s:priorities)
                                for group in groups
                                    for id in s:h.ids[group]
                                        silent! call matchdelete(id)
                                    endfor
                                    let s:h.ids[group] = []
                                endfor
                            endfunction "}}}
    1              0.000005 function! EasyMotion#highlight#add_highlight(re, group) "{{{
                                call add(s:h.ids[a:group], matchadd(a:group, a:re, s:priorities[a:group]))
                            endfunction "}}}
    1              0.000006 function! EasyMotion#highlight#add_pos_highlight(line_num, col_num, group) "{{{
                                call add(s:h.ids[a:group], matchaddpos(a:group, [[a:line_num, a:col_num]], s:priorities[a:group]))
                            endfunction "}}}
    1              0.000003 function! EasyMotion#highlight#attach_autocmd() "{{{
                                " Reference: https://github.com/justinmk/vim-sneak
                                augroup plugin-easymotion
                                    autocmd!
                                    autocmd InsertEnter,WinLeave,BufLeave <buffer>
                                        \ silent! call EasyMotion#highlight#delete_highlight()
                                        \  | autocmd! plugin-easymotion * <buffer>
                                    autocmd CursorMoved <buffer>
                                        \ autocmd plugin-easymotion CursorMoved <buffer>
                                        \ silent! call EasyMotion#highlight#delete_highlight()
                                        \  | autocmd! plugin-easymotion * <buffer>
                                augroup END
                            endfunction "}}}
    1              0.000004 function! EasyMotion#highlight#add_color_group(new_groups) "{{{
                                let s:priorities = extend(deepcopy(s:priorities), a:new_groups)
                                for group in keys(a:new_groups)
                                    let s:h.ids[group] = []
                                endfor
                            endfunction "}}}
                            
    1              0.000004 function! EasyMotion#highlight#capture(hlname) "{{{
                                " Based On: https://github.com/t9md/vim-ezbar
                                "           https://github.com/osyo-manga/vital-over
                                let hlname = a:hlname
                                if !hlexists(hlname)
                                    return
                                endif
                                while 1
                                    let save_verbose = &verbose
                                    let &verbose = 0
                                    try
                                        redir => HL_SAVE
                                        execute 'silent! highlight ' . hlname
                                        redir END
                                    finally
                                        let &verbose = save_verbose
                                    endtry
                                    if !empty(matchstr(HL_SAVE, 'xxx cleared$'))
                                        return ''
                                    endif
                                    " follow highlight link
                                    let ml = matchlist(HL_SAVE, 'links to \zs.*')
                                    if !empty(ml)
                                        let hlname = ml[0]
                                        continue
                                    endif
                                    break
                                endwhile
                                let HL_SAVE = substitute(matchstr(HL_SAVE, 'xxx \zs.*'),
                                                       \ '[ \t\n]\+', ' ', 'g')
                                return [hlname, HL_SAVE]
                            endfunction "}}}
    1              0.000004 function! EasyMotion#highlight#turn_off(hl) "{{{
                                if type(a:hl) != type([])
                                    return
                                endif
                                execute 'highlight ' . a:hl[0] . ' NONE'
                            endfunction "}}}
    1              0.000004 function! EasyMotion#highlight#turn_on(hl) "{{{
                                if type(a:hl) != type([])
                                    return
                                endif
                                execute 'highlight ' . a:hl[0] . ' ' . a:hl[1]
                            endfunction "}}}
                            
                            " Restore 'cpoptions' {{{
    1   0.000042   0.000020 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            " }}}
                            " __END__  {{{
                            " vim: expandtab softtabstop=4 shiftwidth=4
                            " vim: foldmethod=marker
                            " }}}

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/EasyMotion/helper.vim
Sourced 1 time
Total time:   0.000316
 Self time:   0.000310

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/EasyMotion/helper.vim
                            " AUTHOR: haya14busa
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000004 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000009 let s:save_cpo = &cpo
    1   0.000014   0.000012 set cpo&vim
                            " }}}
                            
    1              0.000004 function! EasyMotion#helper#mode(flag) "{{{
                                return mode(a:flag) == "\<C-v>" ? "C-v" : mode(a:flag)
                            endfunction "}}}
                            
    1              0.000003 function! EasyMotion#helper#get_char_by_coord(coord) "{{{
                                " @param coord: [lnum, col] or [bufnum, lnum, col, off]
                                if len(a:coord) == 4
                                    let [line_num, col_num] = [a:coord[1], a:coord[2]]
                                else
                                    let [line_num, col_num] = a:coord
                                endif
                                let target_col_regexp = '\%' . (col_num) . 'c.'
                                return matchstr(getline(line_num), target_col_regexp)
                            endfunction "}}}
                            
    1              0.000003 function! EasyMotion#helper#is_greater_coords(coords1, coords2) "{{{
                                " [line_num, col_num] < [line_num, col_num]
                                "
                                " coords1 < coords2  : return 1
                                " coords1 > coords2  : return -1
                                " coords1 == coords2 : return 0
                                if a:coords1 == a:coords2 | return 0 | endif
                            
                                if a:coords1[0] < a:coords2[0]
                                    return 1
                                elseif a:coords1[0] > a:coords2[0]
                                    return -1
                                endif
                            
                                " Same line
                                if a:coords1[1] < a:coords2[1]
                                    return 1
                                elseif a:coords1[1] > a:coords2[1]
                                    return -1
                                endif
                            endfunction "}}}
                            
    1              0.000003 function! EasyMotion#helper#is_folded(line) "{{{
                                " Return false if g:EasyMotion_skipfoldedline == 1
                                " and line is start of folded lines
                                let _foldclosed = foldclosed(a:line)
                                return _foldclosed != -1 &&
                                    \ (g:EasyMotion_skipfoldedline == 1 || a:line != _foldclosed)
                            endfunction "}}}
    1              0.000003 function! EasyMotion#helper#should_case_sensitive(input, is_search) "{{{
                                if !a:is_search
                                    if g:EasyMotion_smartcase == 0
                                        return 0
                                    else
                                        " return 1 if input didn't match uppercase letter
                                        return match(a:input, '\u') == -1
                                    endif
                                endif
                            
                                if (g:EasyMotion_smartcase == 1 && match(a:input, '\u') == -1) ||
                                \  (&ignorecase && &smartcase && match(a:input, '\u') == -1) ||
                                \  (&ignorecase && !&smartcase)
                                    return 1
                                endif
                                return 0
                            endfunction "}}}
    1              0.000003 function! EasyMotion#helper#silent_feedkeys(expr, name, ...) "{{{
                                " Ref:
                                " https://github.com/osyo-manga/vim-over/blob/d51b028c29661d4a5f5b79438ad6d69266753711/autoload/over.vim#L6
                                let mode = get(a:, 1, "m")
                                let name = "easymotion-" . a:name
                                let map = printf("<Plug>(%s)", name)
                                if mode == "n"
                                    let command = "nnoremap"
                                else
                                    let command = "nmap"
                                endif
                                execute command "<silent>" map printf("%s:nunmap %s<CR>", a:expr, map)
                                if mode(1) !=# 'ce'
                                    " FIXME: mode(1) !=# 'ce' exists only for the test
                                    "        :h feedkeys() doesn't work while runnning a test script
                                    "        https://github.com/kana/vim-vspec/issues/27
                                    call feedkeys(printf("\<Plug>(%s)", name))
                                endif
                            endfunction "}}}
    1              0.000006 function! EasyMotion#helper#VarReset(var, ...) "{{{
                                if ! exists('s:var_reset')
                                    let s:var_reset = {}
                                endif
                            
                                if a:0 == 0 && has_key(s:var_reset, a:var)
                                    " Reset var to original value
                                    " setbufvar( or bufname): '' or '%' can be used for the current buffer
                                    call setbufvar('%', a:var, s:var_reset[a:var])
                                elseif a:0 == 1
                                    " Save original value and set new var value
                            
                                    let new_value = a:0 == 1 ? a:1 : ''
                            
                                    " Store original value
                                    let s:var_reset[a:var] = getbufvar("", a:var)
                            
                                    " Set new var value
                                    call setbufvar('%', a:var, new_value)
                                endif
                            endfunction "}}}
                            
                            " Migemo {{{
    1              0.000002 function! EasyMotion#helper#load_migemo_dict() "{{{
                                let enc = &l:encoding
                                if enc ==# 'utf-8'
                                    return EasyMotion#migemo#utf8#load_dict()
                                elseif enc ==# 'cp932'
                                    return EasyMotion#migemo#cp932#load_dict()
                                elseif enc ==# 'euc-jp'
                                    return EasyMotion#migemo#eucjp#load_dict()
                                else
                                    let g:EasyMotion_use_migemo = 0
                                    throw "Error: ".enc." is not supported. Migemo is made disabled."
                                endif
                            endfunction "}}}
                            
                            " EasyMotion#helper#strchars() {{{
    1              0.000006 if exists('*strchars')
    1              0.000003     function! EasyMotion#helper#strchars(str)
                                    return strchars(a:str)
                                endfunction
    1              0.000002 else
                                function! EasyMotion#helper#strchars(str)
                                    return strlen(substitute(a:str, ".", "x", "g"))
                                endfunction
                            endif "}}}
    1              0.000003 function! EasyMotion#helper#include_multibyte_char(str) "{{{
                                return strlen(a:str) != EasyMotion#helper#strchars(a:str)
                            endfunction "}}}
                            
    1              0.000002 function! EasyMotion#helper#vcol(expr) abort
                                let col_num = col(a:expr)
                                let line = getline(a:expr)
                                let before_line = col_num > 2 ? line[: col_num - 2]
                                \   : col_num is# 2 ? line[0]
                                \   : ''
                                let vcol_num = 1
                                for c in split(before_line, '\zs')
                                    let vcol_num += c is# "\t" ? s:_virtual_tab2spacelen(vcol_num) : len(c)
                                endfor
                                return vcol_num
                            endfunction
                            
    1              0.000008 function! s:_virtual_tab2spacelen(col_num) abort
                                return &tabstop - ((a:col_num - 1) % &tabstop)
                            endfunction
                            
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1   0.000015   0.000012 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/EasyMotion/undo.vim
Sourced 1 time
Total time:   0.007310
 Self time:   0.000291

count  total (s)   self (s)
    1   0.007239   0.000219 let s:Buffer = vital#easymotion#import('Vim.Buffer')
                            
    1              0.000002 function! EasyMotion#undo#save() abort
                              return s:undo_lock.save()
                            endfunction
                            
    1              0.000002 let s:undo_lock = {}
                            
    1              0.000006 function! s:undo_lock.save() abort
                              let undo = deepcopy(self)
                              call undo._save()
                              return undo
                            endfunction
                            
    1              0.000001 function! s:undo_lock._save() abort
                              if undotree().seq_last == 0
                                " if there are no undo history, disable undo feature by setting
                                " 'undolevels' to -1 and restore it.
                                let self.save_undolevels = &l:undolevels
                                let &l:undolevels = -1
                              elseif !s:Buffer.is_cmdwin()
                                " command line window doesn't support :wundo.
                                let self.undofile = tempname()
                                execute 'wundo!' self.undofile
                              else
                                let self.is_cmdwin = s:TRUE
                              endif
                            endfunction
                            
    1              0.000001 function! s:undo_lock.restore() abort
                              if has_key(self, 'save_undolevels')
                                let &l:undolevels = self.save_undolevels
                              endif
                              if has_key(self, 'undofile') && filereadable(self.undofile)
                                silent execute 'rundo' self.undofile
                                call delete(self.undofile)
                              endif
                              if has_key(self, 'is_cmdwin')
                                " XXX: it breaks undo history. AFAIK, there are no way to save and restore
                                " undo history in commandline window.
                                call self.undobreak()
                              endif
                            endfunction
                            
    1              0.000002 function! s:undo_lock.undobreak() abort
                              let old_undolevels = &l:undolevels
                              setlocal undolevels=-1
                              keepjumps call setline('.', getline('.'))
                              let &l:undolevels = old_undolevels
                            endfunction

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/vital/easymotion.vim
Sourced 1 time
Total time:   0.000617
 Self time:   0.000578

count  total (s)   self (s)
    1              0.000013 let s:plugin_name = expand('<sfile>:t:r')
    1              0.000005 let s:vital_base_dir = expand('<sfile>:h')
    1              0.000004 let s:project_root = expand('<sfile>:h:h:h')
    1              0.000004 let s:is_vital_vim = s:plugin_name is# 'vital'
                            
    1              0.000002 let s:loaded = {}
    1              0.000002 let s:cache_sid = {}
                            
                            " function() wrapper
    1              0.000007 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000004   function! s:_function(fstr) abort
                                return function(a:fstr)
                              endfunction
    1              0.000001 else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              let s:_s = '<SNR>' . s:_SID() . '_'
                              function! s:_function(fstr) abort
                                return function(substitute(a:fstr, 's:', s:_s, 'g'))
                              endfunction
                            endif
                            
    1              0.000005 function! vital#{s:plugin_name}#new() abort
                              return s:new(s:plugin_name)
                            endfunction
                            
    1              0.000004 function! vital#{s:plugin_name}#import(...) abort
                              if !exists('s:V')
                                let s:V = s:new(s:plugin_name)
                              endif
                              return call(s:V.import, a:000, s:V)
                            endfunction
                            
    1              0.000002 let s:Vital = {}
                            
    1              0.000002 function! s:new(plugin_name) abort
                              let base = deepcopy(s:Vital)
                              let base._plugin_name = a:plugin_name
                              return base
                            endfunction
                            
    1              0.000002 function! s:vital_files() abort
                              if !exists('s:vital_files')
                                let s:vital_files = map(
                                \   s:is_vital_vim ? s:_global_vital_files() : s:_self_vital_files(),
                                \   'fnamemodify(v:val, ":p:gs?[\\\\/]?/?")')
                              endif
                              return copy(s:vital_files)
                            endfunction
    1   0.000018   0.000012 let s:Vital.vital_files = s:_function('s:vital_files')
                            
    1              0.000002 function! s:import(name, ...) abort dict
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = self._import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
    1   0.000011   0.000006 let s:Vital.import = s:_function('s:import')
                            
    1              0.000002 function! s:load(...) abort dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                let dict_type = type({})
                                while !empty(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == dict_type
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                                if exists('dict')
                                  call extend(dict, self._import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
    1   0.000010   0.000005 let s:Vital.load = s:_function('s:load')
                            
    1              0.000002 function! s:unload() abort dict
                              let s:loaded = {}
                              let s:cache_sid = {}
                              unlet! s:vital_files
                            endfunction
    1   0.000008   0.000004 let s:Vital.unload = s:_function('s:unload')
                            
    1              0.000002 function! s:exists(name) abort dict
                              if a:name !~# '\v^\u\w*%(\.\u\w*)*$'
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                              return s:_module_path(a:name) isnot# ''
                            endfunction
    1   0.000009   0.000005 let s:Vital.exists = s:_function('s:exists')
                            
    1              0.000002 function! s:search(pattern) abort dict
                              let paths = s:_extract_files(a:pattern, self.vital_files())
                              let modules = sort(map(paths, 's:_file2module(v:val)'))
                              return s:_uniq(modules)
                            endfunction
    1   0.000008   0.000004 let s:Vital.search = s:_function('s:search')
                            
    1              0.000002 function! s:plugin_name() abort dict
                              return self._plugin_name
                            endfunction
    1   0.000008   0.000005 let s:Vital.plugin_name = s:_function('s:plugin_name')
                            
    1              0.000002 function! s:_self_vital_files() abort
                              let builtin = printf('%s/__%s__/', s:vital_base_dir, s:plugin_name)
                              let installed = printf('%s/_%s/', s:vital_base_dir, s:plugin_name)
                              let base = builtin . ',' . installed
                              return split(globpath(base, '**/*.vim', 1), "\n")
                            endfunction
                            
    1              0.000002 function! s:_global_vital_files() abort
                              let pattern = 'autoload/vital/__*__/**/*.vim'
                              return split(globpath(&runtimepath, pattern, 1), "\n")
                            endfunction
                            
    1              0.000005 function! s:_extract_files(pattern, files) abort
                              let tr = {'.': '/', '*': '[^/]*', '**': '.*'}
                              let target = substitute(a:pattern, '\.\|\*\*\?', '\=tr[submatch(0)]', 'g')
                              let regexp = printf('autoload/vital/[^/]\+/%s.vim$', target)
                              return filter(a:files, 'v:val =~# regexp')
                            endfunction
                            
    1              0.000002 function! s:_file2module(file) abort
                              let filename = fnamemodify(a:file, ':p:gs?[\\/]?/?')
                              let tail = matchstr(filename, 'autoload/vital/_\w\+/\zs.*\ze\.vim$')
                              return join(split(tail, '[\\/]\+'), '.')
                            endfunction
                            
                            " @param {string} name e.g. Data.List
    1              0.000002 function! s:_import(name) abort dict
                              if has_key(s:loaded, a:name)
                                return copy(s:loaded[a:name])
                              endif
                              let module = self._get_module(a:name)
                              if has_key(module, '_vital_created')
                                call module._vital_created(module)
                              endif
                              let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
                              let s:loaded[a:name] = export_module
                              if has_key(module, '_vital_loaded')
                                try
                                  call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
                                endtry
                              endif
                              return copy(s:loaded[a:name])
                            endfunction
    1   0.000010   0.000006 let s:Vital._import = s:_function('s:_import')
                            
                            " s:_get_module() returns module object wihch has all script local functions.
    1              0.000002 function! s:_get_module(name) abort dict
                              let funcname = s:_import_func_name(self.plugin_name(), a:name)
                              if s:_exists_autoload_func_with_source(funcname)
                                return call(funcname, [])
                              else
                                return s:_get_builtin_module(a:name)
                              endif
                            endfunction
                            
    1              0.000002 function! s:_get_builtin_module(name) abort
                             return s:sid2sfuncs(s:_module_sid(a:name))
                            endfunction
                            
    1              0.000002 if s:is_vital_vim
                              " For vital.vim, we can use s:_get_builtin_module directly
                              let s:Vital._get_module = s:_function('s:_get_builtin_module')
                            else
    1   0.000009   0.000005   let s:Vital._get_module = s:_function('s:_get_module')
    1              0.000001 endif
                            
    1              0.000002 function! s:_import_func_name(plugin_name, module_name) abort
                              return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))
                            endfunction
                            
    1              0.000002 function! s:_module_sid(name) abort
                              let path = s:_module_path(a:name)
                              if !filereadable(path)
                                throw 'vital: module not found: ' . a:name
                              endif
                              let vital_dir = s:is_vital_vim ? '__\w\+__' : printf('_\{1,2}%s\%%(__\)\?', s:plugin_name)
                              let base = join([vital_dir, ''], '[/\\]\+')
                              let p = base . substitute('' . a:name, '\.', '[/\\\\]\\+', 'g')
                              let sid = s:_sid(path, p)
                              if !sid
                                call s:_source(path)
                                let sid = s:_sid(path, p)
                                if !sid
                                  throw printf('vital: cannot get <SID> from path: %s', path)
                                endif
                              endif
                              return sid
                            endfunction
                            
    1              0.000002 function! s:_module_path(name) abort
                              return get(s:_extract_files(a:name, s:vital_files()), 0, '')
                            endfunction
                            
    1              0.000002 function! s:_module_sid_base_dir() abort
                              return s:is_vital_vim ? &rtp : s:project_root
                            endfunction
                            
    1              0.000002 function! s:_dot_to_sharp(name) abort
                              return substitute(a:name, '\.', '#', 'g')
                            endfunction
                            
                            " It will sources autoload file if a given func is not already defined.
    1              0.000003 function! s:_exists_autoload_func_with_source(funcname) abort
                              if exists('*' . a:funcname)
                                " Return true if a given func is already defined
                                return 1
                              endif
                              " source a file which may include a given func definition and try again.
                              let path = 'autoload/' . substitute(substitute(a:funcname, '#[^#]*$', '.vim', ''), '#', '/', 'g')
                              call s:_runtime(path)
                              return exists('*' . a:funcname)
                            endfunction
                            
    1              0.000002 function! s:_runtime(path) abort
                              execute 'runtime' fnameescape(a:path)
                            endfunction
                            
    1              0.000002 function! s:_source(path) abort
                              execute 'source' fnameescape(a:path)
                            endfunction
                            
                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000002 function! s:_sid(path, filter_pattern) abort
                              let unified_path = s:_unify_path(a:path)
                              if has_key(s:cache_sid, unified_path)
                                return s:cache_sid[unified_path]
                              endif
                              for line in filter(split(s:_redir(':scriptnames'), "\n"), 'v:val =~# a:filter_pattern')
                                let [_, sid, path; __] = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if s:_unify_path(path) is# unified_path
                                  let s:cache_sid[unified_path] = sid
                                  return s:cache_sid[unified_path]
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000002 function! s:_redir(cmd) abort
                              let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
                              set verbose=0 verbosefile=
                              redir => res
                                silent! execute a:cmd
                              redir END
                              let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
                              return res
                            endfunction
                            
    1              0.000054 if filereadable(expand('<sfile>:r') . '.VIM') " is case-insensitive or not
    1              0.000004   let s:_unify_path_cache = {}
                              " resolve() is slow, so we cache results.
                              " Note: On windows, vim can't expand path names from 8.3 formats.
                              " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                              " vital load duplicated scripts. Below's :~ avoid this issue.
    1              0.000003   function! s:_unify_path(path) abort
                                if has_key(s:_unify_path_cache, a:path)
                                  return s:_unify_path_cache[a:path]
                                endif
                                let value = tolower(fnamemodify(resolve(fnamemodify(
                                \                   a:path, ':p')), ':~:gs?[\\/]?/?'))
                                let s:_unify_path_cache[a:path] = value
                                return value
                              endfunction
    1              0.000001 else
                              function! s:_unify_path(path) abort
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]?/?'))
                              endfunction
                            endif
                            
                            " copied and modified from Vim.ScriptLocal
    1              0.000035 let s:SNR = join(map(range(len("\<SNR>")), '"[\\x" . printf("%0x", char2nr("\<SNR>"[v:val])) . "]"'), '')
    1              0.000002 function! s:sid2sfuncs(sid) abort
                              let fs = split(s:_redir(printf(':function /^%s%s_', s:SNR, a:sid)), "\n")
                              let r = {}
                              let pattern = printf('\m^function\s<SNR>%d_\zs\w\{-}\ze(', a:sid)
                              for fname in map(fs, 'matchstr(v:val, pattern)')
                                let r[fname] = function(s:_sfuncname(a:sid, fname))
                              endfor
                              return r
                            endfunction
                            
                            "" Return funcname of script local functions with SID
    1              0.000002 function! s:_sfuncname(sid, funcname) abort
                              return printf('<SNR>%s_%s', a:sid, a:funcname)
                            endfunction
                            
    1              0.000004 if exists('*uniq')
    1              0.000002   function! s:_uniq(list) abort
                                return uniq(a:list)
                              endfunction
    1              0.000004 else
                              function! s:_uniq(list) abort
                                let i = len(a:list) - 1
                                while 0 < i
                                  if a:list[i] ==# a:list[i - 1]
                                    call remove(a:list, i)
                                  endif
                                  let i -= 1
                                endwhile
                                return a:list
                              endfunction
                            endif

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/vital/_easymotion/Vim/Buffer.vim
Sourced 1 time
Total time:   0.000392
 Self time:   0.000385

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000010 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Vim#Buffer#import() abort
                                return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
    1              0.000002 else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Vim#Buffer#import() abort', printf("return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
                            endif
                            " ___vital___
    1              0.000010 let s:save_cpo = &cpo
    1   0.000018   0.000014 set cpo&vim
                            
    1              0.000006 function! s:_vital_loaded(V) abort
                              let s:V = a:V
                              let s:P = s:V.import('Prelude')
                              let s:G = s:V.import('Vim.Guard')
                            endfunction
                            
    1              0.000003 function! s:_vital_depends() abort
                              return ['Prelude', 'Vim.Guard']
                            endfunction
                            
    1              0.000007 if exists('*getcmdwintype')
    1              0.000003   function! s:is_cmdwin() abort
                                return getcmdwintype() !=# ''
                              endfunction
    1              0.000002 else
                              function! s:is_cmdwin() abort
                                return bufname('%') ==# '[Command Line]'
                              endfunction
                            endif
                            
    1              0.000017 function! s:open(buffer, opener) abort
                              let save_wildignore = &wildignore
                              let &wildignore = ''
                              try
                                if s:P.is_funcref(a:opener)
                                  let loaded = !bufloaded(a:buffer)
                                  call a:opener(a:buffer)
                                elseif a:buffer is 0 || a:buffer is# ''
                                  let loaded = 1
                                  silent execute a:opener
                                  enew
                                else
                                  let loaded = !bufloaded(a:buffer)
                                  if s:P.is_string(a:buffer)
                                    execute a:opener '`=a:buffer`'
                                  elseif s:P.is_number(a:buffer)
                                    silent execute a:opener
                                    execute a:buffer 'buffer'
                                  else
                                    throw 'vital: Vim.Buffer: Unknown opener type.'
                                  endif
                                endif
                              finally
                                let &wildignore = save_wildignore
                              endtry
                              return loaded
                            endfunction
                            
    1              0.000003 function! s:get_selected_text(...) abort
                              echohl WarningMsg
                              echom "[WARN] s:get_selected_text() is deprecated. Use 's:get_last_selected()'."
                              echohl None
                              return call('s:get_last_selected', a:000)
                            endfunction
                            
                            " Get the last selected text in visual mode
                            " without using |gv| to avoid |textlock|.
                            " NOTE:
                            " * This function uses |gv| only when using |CTRL-V|
                            "   because |gv| is the only way to get selected text
                            "   when using <C-v>$ .
                            "   Please see #192 for the details.
                            " * If you don't care about |textlock|,
                            "   you can use simple version of this function.
                            "   https://github.com/vim-jp/vital.vim/commit/39aae80f3839fdbeebd838ff14d87327a6b889a9
    1              0.000002 function! s:get_last_selected() abort
                              if visualmode() ==# "\<C-v>"
                                let save = getreg('"', 1)
                                let save_type = getregtype('"')
                                try
                                  normal! gv""y
                                  return @"
                                finally
                                  call setreg('"', save, save_type)
                                endtry
                              else
                                let [begin, end] = [getpos("'<"), getpos("'>")]
                                let lastchar = matchstr(getline(end[1])[end[2]-1 :], '.')
                                if begin[1] ==# end[1]
                                  let lines = [getline(begin[1])[begin[2]-1 : end[2]-2]]
                                else
                                  let lines = [getline(begin[1])[begin[2]-1 :]]
                                  \         + (end[1] - begin[1] <# 2 ? [] : getline(begin[1]+1, end[1]-1))
                                  \         + [getline(end[1])[: end[2]-2]]
                                endif
                                return join(lines, "\n") . lastchar . (visualmode() ==# 'V' ? "\n" : '')
                              endif
                            endfunction
                            
    1              0.000003 function! s:read_content(content, ...) abort
                              let options = extend({
                                    \ 'tempfile': '',
                                    \ 'fileformat': '',
                                    \ 'encoding': '',
                                    \ 'binary': 0,
                                    \ 'nobinary': 0,
                                    \ 'bad': '',
                                    \ 'edit': 0,
                                    \ 'line': '',
                                    \}, get(a:000, 0, {}))
                              let tempfile = empty(options.tempfile) ? tempname() : options.tempfile
                              let optnames = [
                                    \ empty(options.fileformat) ? '' : '++ff=' . options.fileformat,
                                    \ empty(options.encoding) ? '' : '++enc=' . options.encoding,
                                    \ empty(options.binary) ? '' : '++bin',
                                    \ empty(options.nobinary) ? '' : '++nobin',
                                    \ empty(options.bad) ? '' : '++bad=' . options.bad,
                                    \ empty(options.edit) ? '' : '++edit',
                                    \]
                              let optname = join(filter(optnames, '!empty(v:val)'))
                              try
                                call writefile(a:content, tempfile)
                                execute printf('keepalt keepjumps %sread %s%s',
                                      \ options.line,
                                      \ empty(optname) ? '' : optname . ' ',
                                      \ fnameescape(tempfile),
                                      \)
                              finally
                                call delete(tempfile)
                                execute 'bwipeout!' tempfile
                              endtry
                            endfunction
                            
    1              0.000004 function! s:edit_content(content, ...) abort
                              let options = extend({
                                    \ 'edit': 1,
                                    \}, get(a:000, 0, {}))
                              let guard = s:G.store(['&l:modifiable'])
                              let saved_view = winsaveview()
                              try
                                let &l:modifiable=1
                                silent keepjumps %delete _
                                silent call s:read_content(a:content, options)
                                silent keepjumps 1delete _
                              finally
                                keepjump call winrestview(saved_view)
                                call guard.restore()
                              endtry
                              setlocal nomodified
                            endfunction
                            
    1              0.000002 function! s:parse_cmdarg(...) abort
                              let cmdarg = get(a:000, 0, v:cmdarg)
                              let options = {}
                              if cmdarg =~# '++enc='
                                let options.encoding = matchstr(cmdarg, '++enc=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++ff='
                                let options.fileformat = matchstr(cmdarg, '++ff=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++bad='
                                let options.bad = matchstr(cmdarg, '++bad=\zs[^ ]\+\ze')
                              endif
                              if cmdarg =~# '++bin'
                                let options.binary = 1
                              endif
                              if cmdarg =~# '++nobin'
                                let options.nobinary = 1
                              endif
                              if cmdarg =~# '++edit'
                                let options.edit = 1
                              endif
                              return options
                            endfunction
                            
    1   0.000021   0.000017 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/vital/_easymotion/Prelude.vim
Sourced 1 time
Total time:   0.000737
 Self time:   0.000731

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000007 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Prelude#import() abort
                                return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''},  'function("s:" . v:key)')
                              endfunction
    1              0.000001 else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Prelude#import() abort', printf("return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
                            endif
                            " ___vital___
    1              0.000007 let s:save_cpo = &cpo
    1   0.000013   0.000010 set cpo&vim
                            
    1              0.000005 if v:version > 703 ||
                            \  (v:version == 703 && has('patch465'))
    1              0.000003   function! s:glob(expr) abort
                                return glob(a:expr, 1, 1)
                              endfunction
    1              0.000001 else
                              function! s:glob(expr) abort
                                return split(glob(a:expr, 1), '\n')
                              endfunction
                            endif
                            
    1              0.000004 if v:version > 704 ||
                            \  (v:version == 704 && has('patch279'))
    1              0.000003   function! s:globpath(path, expr) abort
                                return globpath(a:path, a:expr, 1, 1)
                              endfunction
    1              0.000001 else
                              function! s:globpath(path, expr) abort
                                return split(globpath(a:path, a:expr, 1), '\n')
                              endfunction
                            endif
                            
                            " Wrapper functions for type().
                            " NOTE: __TYPE_FLOAT = -1 when -float.
                            " this doesn't match to anything.
    1              0.000005 if has('patch-7.4.2071')
    1              0.000018   let [
                              \   s:__TYPE_NUMBER,
                              \   s:__TYPE_STRING,
                              \   s:__TYPE_FUNCREF,
                              \   s:__TYPE_LIST,
                              \   s:__TYPE_DICT,
                              \   s:__TYPE_FLOAT] = [
                                    \   v:t_number,
                                    \   v:t_string,
                                    \   v:t_func,
                                    \   v:t_list,
                                    \   v:t_dict,
                                    \   v:t_float]
    1              0.000001 else
                              let [
                              \   s:__TYPE_NUMBER,
                              \   s:__TYPE_STRING,
                              \   s:__TYPE_FUNCREF,
                              \   s:__TYPE_LIST,
                              \   s:__TYPE_DICT,
                              \   s:__TYPE_FLOAT] = [
                                    \   type(3),
                                    \   type(''),
                                    \   type(function('tr')),
                                    \   type([]),
                                    \   type({}),
                                    \   has('float') ? type(str2float('0')) : -1]
                            endif
                            
                            " Number or Float
    1              0.000003 function! s:is_numeric(Value) abort
                              let _ = type(a:Value)
                              return _ ==# s:__TYPE_NUMBER
                              \   || _ ==# s:__TYPE_FLOAT
                            endfunction
                            
                            " Number
    1              0.000002 function! s:is_number(Value) abort
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
                            
                            " String
    1              0.000002 function! s:is_string(Value) abort
                              return type(a:Value) ==# s:__TYPE_STRING
                            endfunction
                            
                            " Funcref
    1              0.000002 function! s:is_funcref(Value) abort
                              return type(a:Value) ==# s:__TYPE_FUNCREF
                            endfunction
                            
                            " List
    1              0.000002 function! s:is_list(Value) abort
                              return type(a:Value) ==# s:__TYPE_LIST
                            endfunction
                            
                            " Dictionary
    1              0.000002 function! s:is_dict(Value) abort
                              return type(a:Value) ==# s:__TYPE_DICT
                            endfunction
                            
                            " Float
    1              0.000002 function! s:is_float(Value) abort
                              return type(a:Value) ==# s:__TYPE_FLOAT
                            endfunction
                            
                            
    1              0.000004 function! s:truncate_skipping(str, max, footer_width, separator) abort
                              call s:_warn_deprecated('truncate_skipping', 'Data.String.truncate_skipping')
                            
                              let width = s:wcswidth(a:str)
                              if width <= a:max
                                let ret = a:str
                              else
                                let header_width = a:max - s:wcswidth(a:separator) - a:footer_width
                                let ret = s:strwidthpart(a:str, header_width) . a:separator
                                      \ . s:strwidthpart_reverse(a:str, a:footer_width)
                              endif
                            
                              return s:truncate(ret, a:max)
                            endfunction
                            
    1              0.000002 function! s:truncate(str, width) abort
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
                              call s:_warn_deprecated('truncate', 'Data.String.truncate')
                            
                              if a:str =~# '^[\x00-\x7f]*$'
                                return len(a:str) < a:width ?
                                      \ printf('%-'.a:width.'s', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = s:wcswidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000002 function! s:strwidthpart(str, width) abort
                              call s:_warn_deprecated('strwidthpart', 'Data.String.strwidthpart')
                            
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '.$')
                                let ret = ret[: -1 - len(char)]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
    1              0.000003 function! s:strwidthpart_reverse(str, width) abort
                              call s:_warn_deprecated('strwidthpart_reverse', 'Data.String.strwidthpart_reverse')
                            
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '^.')
                                let ret = ret[len(char) :]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
                            
    1              0.000002 if v:version >= 703
                              " Use builtin function.
    1              0.000005   function! s:wcswidth(str) abort
                                call s:_warn_deprecated('wcswidth', 'Data.String.wcswidth')
                                return strwidth(a:str)
                              endfunction
    1              0.000001 else
                              function! s:wcswidth(str) abort
                                call s:_warn_deprecated('wcswidth', 'Data.String.wcswidth')
                            
                                if a:str =~# '^[\x00-\x7f]*$'
                                  return strlen(a:str)
                                end
                            
                                let mx_first = '^\(.\)'
                                let str = a:str
                                let width = 0
                                while 1
                                  let ucs = char2nr(substitute(str, mx_first, '\1', ''))
                                  if ucs == 0
                                    break
                                  endif
                                  let width += s:_wcwidth(ucs)
                                  let str = substitute(str, mx_first, '', '')
                                endwhile
                                return width
                              endfunction
                            
                              " UTF-8 only.
                              function! s:_wcwidth(ucs) abort
                                let ucs = a:ucs
                                if (ucs >= 0x1100
                                      \  && (ucs <= 0x115f
                                      \  || ucs == 0x2329
                                      \  || ucs == 0x232a
                                      \  || (ucs >= 0x2e80 && ucs <= 0xa4cf
                                      \      && ucs != 0x303f)
                                      \  || (ucs >= 0xac00 && ucs <= 0xd7a3)
                                      \  || (ucs >= 0xf900 && ucs <= 0xfaff)
                                      \  || (ucs >= 0xfe30 && ucs <= 0xfe6f)
                                      \  || (ucs >= 0xff00 && ucs <= 0xff60)
                                      \  || (ucs >= 0xffe0 && ucs <= 0xffe6)
                                      \  || (ucs >= 0x20000 && ucs <= 0x2fffd)
                                      \  || (ucs >= 0x30000 && ucs <= 0x3fffd)
                                      \  ))
                                  return 2
                                endif
                                return 1
                              endfunction
                            endif
                            
    1              0.000014 let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')
    1              0.000005 let s:is_cygwin = has('win32unix')
    1              0.000011 let s:is_mac = !s:is_windows && !s:is_cygwin
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
    1              0.000003 let s:is_unix = has('unix')
                            
    1              0.000002 function! s:is_windows() abort
                              return s:is_windows
                            endfunction
                            
    1              0.000002 function! s:is_cygwin() abort
                              return s:is_cygwin
                            endfunction
                            
    1              0.000005 function! s:is_mac() abort
                              return s:is_mac
                            endfunction
                            
    1              0.000002 function! s:is_unix() abort
                              return s:is_unix
                            endfunction
                            
    1              0.000002 function! s:_warn_deprecated(name, alternative) abort
                              try
                                echohl Error
                                echomsg 'Prelude.' . a:name . ' is deprecated!  Please use ' . a:alternative . ' instead.'
                              finally
                                echohl None
                              endtry
                            endfunction
                            
    1              0.000002 function! s:smart_execute_command(action, word) abort
                              execute a:action . ' ' . (a:word ==# '' ? '' : '`=a:word`')
                            endfunction
                            
    1              0.000002 function! s:escape_file_searching(buffer_name) abort
                              return escape(a:buffer_name, '*[]?{}, ')
                            endfunction
                            
    1              0.000003 function! s:escape_pattern(str) abort
                              call s:_warn_deprecated(
                                    \ 'escape_pattern',
                                    \ 'Data.String.escape_pattern',
                                    \)
                              return escape(a:str, '~"\.^$[]*')
                            endfunction
                            
    1              0.000004 function! s:getchar(...) abort
                              let c = call('getchar', a:000)
                              return type(c) == type(0) ? nr2char(c) : c
                            endfunction
                            
    1              0.000024 function! s:getchar_safe(...) abort
                              let c = s:input_helper('getchar', a:000)
                              return type(c) == type('') ? c : nr2char(c)
                            endfunction
                            
    1              0.000005 function! s:input_safe(...) abort
                              return s:input_helper('input', a:000)
                            endfunction
                            
    1              0.000004 function! s:input_helper(funcname, args) abort
                              let success = 0
                              if inputsave() !=# success
                                throw 'vital: Prelude: inputsave() failed'
                              endif
                              try
                                return call(a:funcname, a:args)
                              finally
                                if inputrestore() !=# success
                                  throw 'vital: Prelude: inputrestore() failed'
                                endif
                              endtry
                            endfunction
                            
    1              0.000005 function! s:set_default(var, val) abort
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let {a:var} = a:val
                              endif
                            endfunction
                            
    1              0.000003 function! s:substitute_path_separator(path) abort
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction
                            
    1              0.000002 function! s:path2directory(path) abort
                              return s:substitute_path_separator(isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))
                            endfunction
                            
    1              0.000002 function! s:_path2project_directory_git(path) abort
                              let parent = a:path
                            
                              while 1
                                let path = parent . '/.git'
                                if isdirectory(path) || filereadable(path)
                                  return parent
                                endif
                                let next = fnamemodify(parent, ':h')
                                if next == parent
                                  return ''
                                endif
                                let parent = next
                              endwhile
                            endfunction
                            
    1              0.000002 function! s:_path2project_directory_svn(path) abort
                              let search_directory = a:path
                              let directory = ''
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir('.svn', find_directory . ';')
                              if d ==# ''
                                return ''
                              endif
                            
                              let directory = fnamemodify(d, ':p:h:h')
                            
                              " Search parent directories.
                              let parent_directory = s:path2directory(
                                    \ fnamemodify(directory, ':h'))
                            
                              if parent_directory !=# ''
                                let d = finddir('.svn', parent_directory . ';')
                                if d !=# ''
                                  let directory = s:_path2project_directory_svn(parent_directory)
                                endif
                              endif
                              return directory
                            endfunction
                            
    1              0.000003 function! s:_path2project_directory_others(vcs, path) abort
                              let vcs = a:vcs
                              let search_directory = a:path
                            
                              let find_directory = s:escape_file_searching(search_directory)
                              let d = finddir(vcs, find_directory . ';')
                              if d ==# ''
                                return ''
                              endif
                              return fnamemodify(d, ':p:h:h')
                            endfunction
                            
    1              0.000006 function! s:path2project_directory(path, ...) abort
                              let is_allow_empty = get(a:000, 0, 0)
                              let search_directory = s:path2directory(a:path)
                              let directory = ''
                            
                              " Search VCS directory.
                              for vcs in ['.git', '.bzr', '.hg', '.svn']
                                if vcs ==# '.git'
                                  let directory = s:_path2project_directory_git(search_directory)
                                elseif vcs ==# '.svn'
                                  let directory = s:_path2project_directory_svn(search_directory)
                                else
                                  let directory = s:_path2project_directory_others(vcs, search_directory)
                                endif
                                if directory !=# ''
                                  break
                                endif
                              endfor
                            
                              " Search project file.
                              if directory ==# ''
                                for d in ['build.xml', 'prj.el', '.project', 'pom.xml', 'package.json',
                                      \ 'Makefile', 'configure', 'Rakefile', 'NAnt.build',
                                      \ 'P4CONFIG', 'tags', 'gtags']
                                  let d = findfile(d, s:escape_file_searching(search_directory) . ';')
                                  if d !=# ''
                                    let directory = fnamemodify(d, ':p:h')
                                    break
                                  endif
                                endfor
                              endif
                            
                              if directory ==# ''
                                " Search /src/ directory.
                                let base = s:substitute_path_separator(search_directory)
                                if base =~# '/src/'
                                  let directory = base[: strridx(base, '/src/') + 3]
                                endif
                              endif
                            
                              if directory ==# '' && !is_allow_empty
                                " Use original path.
                                let directory = search_directory
                              endif
                            
                              return s:substitute_path_separator(directory)
                            endfunction
                            
    1   0.000017   0.000013 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/vital/_easymotion/Vim/Guard.vim
Sourced 1 time
Total time:   0.000351
 Self time:   0.000342

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000003   function! vital#_easymotion#Vim#Guard#import() abort
                                return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
    1              0.000001 else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Vim#Guard#import() abort', printf("return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
                            endif
                            " ___vital___
    1              0.000006 let s:save_cpo = &cpo
    1   0.000011   0.000009 set cpo&vim
                            
                            " Use a Funcref as a special term _UNDEFINED
    1              0.000002 function! s:_undefined() abort
                              return 'undefined'
                            endfunction
    1              0.000008 let s:_UNDEFINED = function('s:_undefined')
                            
    1              0.000002 function! s:_vital_loaded(V) abort
                              let s:V = a:V
                              let s:Prelude = s:V.import('Prelude')
                              let s:List = s:V.import('Data.List')
                              let s:Dict = s:V.import('Data.Dict')
                            endfunction
    1              0.000002 function! s:_vital_depends() abort
                              return ['Prelude', 'Data.List', 'Data.Dict']
                            endfunction
    1              0.000002 function! s:_vital_created(module) abort
                              " define constant variables
                              if !exists('s:const')
                                let s:const = {}
                                let s:const.is_local_variable_supported =
                                    \ v:version > 703 || (v:version == 703 && has('patch560'))
                                " NOTE:
                                " The third argument is available from 7.4.242 but it had bug and that
                                " bug was fixed from 7.4.513
                                let s:const.is_third_argument_of_getreg_supported = has('patch-7.4.513')
                                lockvar s:const
                              endif
                              call extend(a:module, s:const)
                            endfunction
    1              0.000002 function! s:_throw(msg) abort
                              throw printf('vital: Vim.Guard: %s', a:msg)
                            endfunction
                            
    1              0.000002 let s:option = {}
    1              0.000005 function! s:_new_option(name) abort
                              if a:name !~# '^&'
                                call s:_throw(printf(
                                      \'An option name "%s" requires to be started from "&"', a:name
                                      \))
                              elseif !exists(a:name)
                                call s:_throw(printf(
                                      \'An option name "%s" does not exist', a:name
                                      \))
                              endif
                              let option = copy(s:option)
                              let option.name = a:name
                              let option.value = eval(a:name)
                              return option
                            endfunction
    1              0.000002 function! s:option.restore() abort
                              execute printf('let %s = %s', self.name, string(self.value))
                            endfunction
                            
    1              0.000002 let s:register = {}
    1              0.000002 function! s:_new_register(name) abort
                              if len(a:name) != 2
                                call s:_throw(printf(
                                      \'A register name "%s" requires to be "@" + a single character', a:name
                                      \))
                              elseif a:name !~# '^@'
                                call s:_throw(printf(
                                      \'A register name "%s" requires to be started from "@"', a:name
                                      \))
                              elseif a:name =~# '^@[:.%]$'
                                call s:_throw(printf(
                                      \'A register name "%s" is read only', a:name
                                      \))
                              elseif a:name !~# '^@[@0-9a-zA-Z#=*+~_/-]$'
                                call s:_throw(printf(
                                      \'A register name "%s" does not exist. See ":help let-register"', a:name
                                      \))
                              endif
                              let name = a:name ==# '@@' ? '' : a:name[1]
                              let register = copy(s:register)
                              let register.name = name
                              if s:const.is_third_argument_of_getreg_supported
                                let register.value = getreg(name, 1, 1)
                              else
                                let register.value = getreg(name, 1)
                              endif
                              let register.type = getregtype(name)
                              return register
                            endfunction
    1              0.000002 function! s:register.restore() abort
                              " https://github.com/vim/vim/commit/5a50c2255c447838d08d3b4895a3be3a41cd8eda
                              if has('patch-7.4.243') || self.name !=# '='
                                call setreg(self.name, self.value, self.type)
                              else
                                let @= = self.value
                              endif
                            endfunction
                            
    1              0.000003 let s:environment = {}
    1              0.000002 function! s:_new_environment(name) abort
                              if a:name !~# '^\$'
                                call s:_throw(printf(
                                      \'An environment variable name "%s" requires to be started from "$"', a:name
                                      \))
                              elseif !exists(a:name)
                                call s:_throw(printf(
                                      \'An environment variable name "%s" does not exist. While Vim cannot unlet environment variable, it requires to exist', a:name
                                      \))
                              endif
                              let environment = copy(s:environment)
                              let environment.name = a:name
                              let environment.value = eval(a:name)
                              return environment
                            endfunction
    1              0.000002 function! s:environment.restore() abort
                              execute printf('let %s = %s', self.name, string(self.value))
                            endfunction
                            
    1              0.000002 let s:variable = {}
    1              0.000002 function! s:_new_variable(name, ...) abort
                              if a:0 == 0
                                let m = matchlist(a:name, '^\([bwtg]:\)\(.*\)$')
                                if empty(m)
                                  call s:_throw(printf(
                                        \ join([
                                        \   'An variable name "%s" requires to start from b:, w:, t:, or g:',
                                        \   'while no {namespace} is specified',
                                        \ ]),
                                        \ a:name,
                                        \))
                                endif
                                let [prefix, name] = m[1 : 2]
                                let namespace = eval(prefix)
                              else
                                let name = a:name
                                let namespace = a:1
                              endif
                              let variable = copy(s:variable)
                              let variable.name = name
                              let variable.value = get(namespace, name, s:_UNDEFINED)
                              let variable.value =
                                    \ type(variable.value) == type({}) || type(variable.value) == type([])
                                    \   ? deepcopy(variable.value)
                                    \   : variable.value
                              let variable._namespace = namespace
                              return variable
                            endfunction
    1              0.000002 function! s:variable.restore() abort
                              " unlet the variable to prevent variable type mis-match in case
                              silent! unlet! self._namespace[self.name]
                              if type(self.value) == type(s:_UNDEFINED) && self.value == s:_UNDEFINED
                                " do nothing, leave the variable as undefined
                              else
                                let self._namespace[self.name] = self.value
                              endif
                            endfunction
                            
    1              0.000002 let s:instance = {}
    1              0.000002 function! s:_new_instance(instance, ...) abort
                              let shallow = get(a:000, 0, 0)
                              if !s:Prelude.is_list(a:instance) && !s:Prelude.is_dict(a:instance)
                                call s:_throw(printf(
                                      \'An instance "%s" requires to be List or Dictionary', string(a:instance)
                                      \))
                              endif
                              let instance = copy(s:instance)
                              let instance.instance = a:instance
                              let instance.values = shallow ? copy(a:instance) : deepcopy(a:instance)
                              return instance
                            endfunction
    1              0.000001 function! s:instance.restore() abort
                              if s:Prelude.is_list(self.instance)
                                call s:List.clear(self.instance)
                              else
                                call s:Dict.clear(self.instance)
                              endif
                              call extend(self.instance, self.values)
                            endfunction
                            
    1              0.000002 let s:guard = {}
    1              0.000002 function! s:store(targets) abort
                              let resources = []
                              for meta in a:targets
                                if s:Prelude.is_list(meta)
                                  if len(meta) == 1
                                    call add(resources, s:_new_instance(meta[0]))
                                  elseif len(meta) == 2
                                    if s:Prelude.is_string(meta[0])
                                      call add(resources, call('s:_new_variable', meta))
                                    else
                                      call add(resources, call('s:_new_instance', meta))
                                    endif
                                  else
                                    call s:_throw('List assignment requires one or two elements')
                                  endif
                                elseif type(meta) == type('')
                                  if meta =~# '^[bwtgls]:'
                                    " Note:
                                    " To improve an error message, handle l:XXX or s:XXX as well
                                    call add(resources, s:_new_variable(meta))
                                  elseif meta =~# '^&'
                                    call add(resources, s:_new_option(meta))
                                  elseif meta =~# '^@'
                                    call add(resources, s:_new_register(meta))
                                  elseif meta =~# '^\$'
                                    call add(resources, s:_new_environment(meta))
                                  else
                                    call s:_throw(printf(
                                          \ 'Unknown value "%s" was specified',
                                          \ meta
                                          \))
                                  endif
                                endif
                                unlet meta
                              endfor
                              let guard = copy(s:guard)
                              let guard._resources = resources
                              return guard
                            endfunction
    1              0.000002 function! s:guard.restore() abort
                              for resource in self._resources
                                call resource.restore()
                              endfor
                            endfunction
                            
    1   0.000016   0.000010 let &cpo = s:save_cpo
    1              0.000003 unlet! s:save_cpo
                            " vim:set et ts=2 sts=2 sw=2 tw=0 fdm=marker:

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/vital/_easymotion/Data/List.vim
Sourced 1 time
Total time:   0.000527
 Self time:   0.000519

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Data#List#import() abort
                                return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''},  'function("s:" . v:key)')
                              endfunction
    1              0.000001 else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Data#List#import() abort', printf("return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
                            endif
                            " ___vital___
                            " Utilities for list.
                            
    1              0.000006 let s:save_cpo = &cpo
    1   0.000011   0.000009 set cpo&vim
                            
    1              0.000003 function! s:pop(list) abort
                              return remove(a:list, -1)
                            endfunction
                            
    1              0.000006 function! s:push(list, val) abort
                              call add(a:list, a:val)
                              return a:list
                            endfunction
                            
    1              0.000002 function! s:shift(list) abort
                              return remove(a:list, 0)
                            endfunction
                            
    1              0.000002 function! s:unshift(list, val) abort
                              return insert(a:list, a:val)
                            endfunction
                            
    1              0.000002 function! s:cons(x, xs) abort
                              return [a:x] + a:xs
                            endfunction
                            
    1              0.000002 function! s:conj(xs, x) abort
                              return a:xs + [a:x]
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000002 function! s:uniq(list) abort
                              return s:uniq_by(a:list, 'v:val')
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000002 function! s:uniq_by(list, f) abort
                              let list = map(copy(a:list), printf('[v:val, %s]', a:f))
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, 'v:val[0]')
                            endfunction
                            
    1              0.000002 function! s:clear(list) abort
                              if !empty(a:list)
                                unlet! a:list[0 : len(a:list) - 1]
                              endif
                              return a:list
                            endfunction
                            
                            " Concatenates a list of lists.
                            " XXX: Should we verify the input?
    1              0.000002 function! s:concat(list) abort
                              let memo = []
                              for Value in a:list
                                let memo += Value
                              endfor
                              return memo
                            endfunction
                            
                            " Take each elements from lists to a new list.
    1              0.000002 function! s:flatten(list, ...) abort
                              let limit = a:0 > 0 ? a:1 : -1
                              let memo = []
                              if limit == 0
                                return a:list
                              endif
                              let limit -= 1
                              for Value in a:list
                                let memo +=
                                      \ type(Value) == type([]) ?
                                      \   s:flatten(Value, limit) :
                                      \   [Value]
                                unlet! Value
                              endfor
                              return memo
                            endfunction
                            
                            " Sorts a list with expression to compare each two values.
                            " a:a and a:b can be used in {expr}.
    1              0.000002 function! s:sort(list, expr) abort
                              if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
                              endif
                              let s:expr = a:expr
                              return sort(a:list, 's:_compare')
                            endfunction
                            
    1              0.000002 function! s:_compare(a, b) abort
                              return eval(s:expr)
                            endfunction
                            
                            " Sorts a list using a set of keys generated by mapping the values in the list
                            " through the given expr.
                            " v:val is used in {expr}
    1              0.000002 function! s:sort_by(list, expr) abort
                              let pairs = map(a:list, printf('[v:val, %s]', a:expr))
                              return map(s:sort(pairs,
                              \      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')
                            endfunction
                            
                            " Returns a maximum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
    1              0.000002 function! s:max_by(list, expr) abort
                              if empty(a:list)
                                return 0
                              endif
                              let list = map(copy(a:list), a:expr)
                              return a:list[index(list, max(list))]
                            endfunction
                            
                            " Returns a minimum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
                            " FIXME: -0x80000000 == 0x80000000
    1              0.000002 function! s:min_by(list, expr) abort
                              return s:max_by(a:list, '-(' . a:expr . ')')
                            endfunction
                            
                            " Returns List of character sequence between [a:from, a:to]
                            " e.g.: s:char_range('a', 'c') returns ['a', 'b', 'c']
    1              0.000002 function! s:char_range(from, to) abort
                              return map(
                              \   range(char2nr(a:from), char2nr(a:to)),
                              \   'nr2char(v:val)'
                              \)
                            endfunction
                            
                            " Returns true if a:list has a:value.
                            " Returns false otherwise.
    1              0.000002 function! s:has(list, value) abort
                              return index(a:list, a:value) isnot -1
                            endfunction
                            
                            " Returns true if a:list[a:index] exists.
                            " Returns false otherwise.
                            " NOTE: Returns false when a:index is negative number.
    1              0.000002 function! s:has_index(list, index) abort
                              " Return true when negative index?
                              " let index = a:index >= 0 ? a:index : len(a:list) + a:index
                              return 0 <= a:index && a:index < len(a:list)
                            endfunction
                            
                            " similar to Haskell's Data.List.span
    1              0.000002 function! s:span(f, xs) abort
                              let border = len(a:xs)
                              for i in range(len(a:xs))
                                if !eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  let border = i
                                  break
                                endif
                              endfor
                              return border == 0 ? [[], copy(a:xs)] : [a:xs[: border - 1], a:xs[border :]]
                            endfunction
                            
                            " similar to Haskell's Data.List.break
    1              0.000002 function! s:break(f, xs) abort
                              return s:span(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Data.List.takeWhile
    1              0.000002 function! s:take_while(f, xs) abort
                              return s:span(a:f, a:xs)[0]
                            endfunction
                            
                            " similar to Haskell's Data.List.partition
    1              0.000002 function! s:partition(f, xs) abort
                              return [filter(copy(a:xs), a:f), filter(copy(a:xs), '!(' . a:f . ')')]
                            endfunction
                            
                            " similar to Haskell's Prelude.all
    1              0.000002 function! s:all(f, xs) abort
                              return !s:any(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.any
    1              0.000002 function! s:any(f, xs) abort
                              return !empty(filter(map(copy(a:xs), a:f), 'v:val'))
                            endfunction
                            
                            " similar to Haskell's Prelude.and
    1              0.000001 function! s:and(xs) abort
                              return s:all('v:val', a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.or
    1              0.000002 function! s:or(xs) abort
                              return s:any('v:val', a:xs)
                            endfunction
                            
    1              0.000002 function! s:map_accum(expr, xs, init) abort
                              let memo = []
                              let init = a:init
                              for x in a:xs
                                let expr = substitute(a:expr, 'v:memo', init, 'g')
                                let expr = substitute(expr, 'v:val', x, 'g')
                                let [tmp, init] = eval(expr)
                                call add(memo, tmp)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl
    1              0.000002 function! s:foldl(f, init, xs) abort
                              let memo = a:init
                              for x in a:xs
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl1
    1              0.000002 function! s:foldl1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldl1'
                              endif
                              return s:foldl(a:f, a:xs[0], a:xs[1:])
                            endfunction
                            
                            " similar to Haskell's Prelude.foldr
    1              0.000004 function! s:foldr(f, init, xs) abort
                              return s:foldl(a:f, a:init, reverse(copy(a:xs)))
                            endfunction
                            
                            " similar to Haskell's Prelude.fold11
    1              0.000002 function! s:foldr1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldr1'
                              endif
                              return s:foldr(a:f, a:xs[-1], a:xs[0:-2])
                            endfunction
                            
                            " similar to python's zip()
    1              0.000001 function! s:zip(...) abort
                              return map(range(min(map(copy(a:000), 'len(v:val)'))), "map(copy(a:000), 'v:val['.v:val.']')")
                            endfunction
                            
                            " similar to zip(), but goes until the longer one.
    1              0.000002 function! s:zip_fill(xs, ys, filler) abort
                              if empty(a:xs) && empty(a:ys)
                                return []
                              elseif empty(a:ys)
                                return s:cons([a:xs[0], a:filler], s:zip_fill(a:xs[1 :], [], a:filler))
                              elseif empty(a:xs)
                                return s:cons([a:filler, a:ys[0]], s:zip_fill([], a:ys[1 :], a:filler))
                              else
                                return s:cons([a:xs[0], a:ys[0]], s:zip_fill(a:xs[1 :], a:ys[1: ], a:filler))
                              endif
                            endfunction
                            
                            " Inspired by Ruby's with_index method.
    1              0.000002 function! s:with_index(list, ...) abort
                              let base = a:0 > 0 ? a:1 : 0
                              return map(copy(a:list), '[v:val, v:key + base]')
                            endfunction
                            
                            " similar to Ruby's detect or Haskell's find.
    1              0.000002 function! s:find(list, default, f) abort
                              for x in a:list
                                if eval(substitute(a:f, 'v:val', string(x), 'g'))
                                  return x
                                endif
                              endfor
                              return a:default
                            endfunction
                            
                            " Returns the index of the first element which satisfies the given expr.
    1              0.000002 function! s:find_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction
                            
                            " Returns the index of the last element which satisfies the given expr.
    1              0.000002 function! s:find_last_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : len - 1
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, 0, -1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction
                            
                            " Similar to find_index but returns the list of indices satisfying the given expr.
    1              0.000002 function! s:find_indices(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let result = []
                              if start >=# len || start < 0
                                return result
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  call add(result, i)
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " Return non-zero if a:list1 and a:list2 have any common item(s).
                            " Return zero otherwise.
    1              0.000005 function! s:has_common_items(list1, list2) abort
                              return !empty(filter(copy(a:list1), 'index(a:list2, v:val) isnot -1'))
                            endfunction
                            
    1              0.000002 function! s:intersect(list1, list2) abort
                              let items = []
                              " for funcref
                              for X in a:list1
                                if index(a:list2, X) != -1 && index(items, X) == -1
                                  let items += [X]
                                endif
                              endfor
                              return items
                            endfunction
                            
                            " similar to Ruby's group_by.
    1              0.000002 function! s:group_by(xs, f) abort
                              let result = {}
                              let list = map(copy(a:xs), printf('[v:val, %s]', a:f))
                              for x in list
                                let Val = x[0]
                                let key = type(x[1]) !=# type('') ? string(x[1]) : x[1]
                                if has_key(result, key)
                                  call add(result[key], Val)
                                else
                                  let result[key] = [Val]
                                endif
                                unlet Val
                              endfor
                              return result
                            endfunction
                            
    1              0.000005 function! s:_default_compare(a, b) abort
                              return a:a <# a:b ? -1 : a:a ># a:b ? 1 : 0
                            endfunction
                            
    1              0.000002 function! s:binary_search(list, value, ...) abort
                              let Predicate = a:0 >= 1 ? a:1 : 's:_default_compare'
                              let dic = a:0 >= 2 ? a:2 : {}
                              let start = 0
                              let end = len(a:list) - 1
                            
                              while 1
                                if start > end
                                  return -1
                                endif
                            
                                let middle = (start + end) / 2
                            
                                let compared = call(Predicate, [a:value, a:list[middle]], dic)
                            
                                if compared < 0
                                  let end = middle - 1
                                elseif compared > 0
                                  let start = middle + 1
                                else
                                  return middle
                                endif
                              endwhile
                            endfunction
                            
    1              0.000002 function! s:product(lists) abort
                              let result = [[]]
                              for pool in a:lists
                                let tmp = []
                                for x in result
                                  let tmp += map(copy(pool), 'x + [v:val]')
                                endfor
                                let result = tmp
                              endfor
                              return result
                            endfunction
                            
    1              0.000002 function! s:permutations(list, ...) abort
                              if a:0 > 1
                                throw 'vital: Data.List: too many arguments'
                              endif
                              let r = a:0 == 1 ? a:1 : len(a:list)
                              if r > len(a:list)
                                return []
                              elseif r < 0
                                throw 'vital: Data.List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:product(map(range(r), 'range(n)'))
                                if len(s:uniq(indices)) == r
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction
                            
    1              0.000002 function! s:combinations(list, r) abort
                              if a:r > len(a:list)
                                return []
                              elseif a:r < 0
                                throw 'vital: Data:List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:permutations(range(n), a:r)
                                if s:sort(copy(indices), 'a:a - a:b') == indices
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction
                            
    1   0.000016   0.000010 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/masatoshi/.cache/dein/repos/github.com/easymotion/vim-easymotion/autoload/vital/_easymotion/Data/Dict.vim
Sourced 1 time
Total time:   0.000195
 Self time:   0.000186

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000003   function! vital#_easymotion#Data#Dict#import() abort
                                return map({'pick': '', 'clear': '', 'max_by': '', 'foldl': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': ''},  'function("s:" . v:key)')
                              endfunction
    1              0.000001 else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Data#Dict#import() abort', printf("return map({'pick': '', 'clear': '', 'max_by': '', 'foldl': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
                            endif
                            " ___vital___
                            " Utilities for dictionary.
                            
    1              0.000006 let s:save_cpo = &cpo
    1   0.000016   0.000009 set cpo&vim
                            
                            " Makes a dict from keys and values
    1              0.000003 function! s:make(keys, values, ...) abort
                              let dict = {}
                              let fill = a:0 ? a:1 : 0
                              for i in range(len(a:keys))
                                let key = type(a:keys[i]) == type('') ? a:keys[i] : string(a:keys[i])
                                if key ==# ''
                                  throw "vital: Data.Dict: Can't use an empty string for key."
                                endif
                                let dict[key] = get(a:values, i, fill)
                              endfor
                              return dict
                            endfunction
                            
                            " Swaps keys and values
    1              0.000002 function! s:swap(dict) abort
                              return s:make(values(a:dict), keys(a:dict))
                            endfunction
                            
                            " Makes a index dict from a list
    1              0.000002 function! s:make_index(list, ...) abort
                              let value = a:0 ? a:1 : 1
                              return s:make(a:list, [], value)
                            endfunction
                            
    1              0.000002 function! s:pick(dict, keys) abort
                              let new_dict = {}
                              for key in a:keys
                                if has_key(a:dict, key)
                                  let new_dict[key] = a:dict[key]
                                endif
                              endfor
                              return new_dict
                            endfunction
                            
    1              0.000002 function! s:omit(dict, keys) abort
                              let new_dict = copy(a:dict)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  call remove(new_dict, key)
                                endif
                              endfor
                              return new_dict
                            endfunction
                            
    1              0.000002 function! s:clear(dict) abort
                              for key in keys(a:dict)
                                call remove(a:dict, key)
                              endfor
                              return a:dict
                            endfunction
                            
    1              0.000002 function! s:_max_by(dict, expr) abort
                              let dict = s:swap(map(copy(a:dict), a:expr))
                              let key = dict[max(keys(dict))]
                              return [key, a:dict[key]]
                            endfunction
                            
    1              0.000002 function! s:max_by(dict, expr) abort
                              if empty(a:dict)
                                throw 'vital: Data.Dict: Empty dictionary'
                              endif
                              return s:_max_by(a:dict, a:expr)
                            endfunction
                            
    1              0.000002 function! s:min_by(dict, expr) abort
                              if empty(a:dict)
                                throw 'vital: Data.Dict: Empty dictionary'
                              endif
                              return s:_max_by(a:dict, '-(' . a:expr . ')')
                            endfunction
                            
    1              0.000002 function! s:_foldl(f, init, xs) abort
                              let memo = a:init
                              for [k, v] in a:xs
                                let expr = substitute(a:f, 'v:key', string(k), 'g')
                                let expr = substitute(expr, 'v:val', string(v), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
    1              0.000002 function! s:foldl(f, init, dict) abort
                              return s:_foldl(a:f, a:init, items(a:dict))
                            endfunction
                            
    1              0.000002 function! s:foldr(f, init, dict) abort
                              return s:_foldl(a:f, a:init, reverse(items(a:dict)))
                            endfunction
                            
    1   0.000011   0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

FUNCTION  <SNR>141_EasyMotion()
Called 1 time
Total time:   0.073302
 Self time:   0.001938

count  total (s)   self (s)
    1   0.000056   0.000033     let config = extend(s:default_config(), get(a:, 1, {}))
                                " Store s:current original_position & cursor_position {{{
                                " current cursor pos.
    1              0.000008     let s:current.cursor_position = [line('.'), col('.')]
                                " original start position.  This value could be changed later in visual
                                " mode
    1              0.000007     let s:current.original_position = get(s:current, 'original_position', s:current.cursor_position)
                                "}}}
                            
    1              0.000026     let win_first_line = line('w0') " visible first line num
    1              0.000003     let win_last_line  = line('w$') " visible last line num
                            
                                " Store the target positions list
                                " e.g. targets = [ [line, col], [line2, col2], ...]
    1              0.000002     let targets = []
                            
                                " Store info for Repeat motion {{{
    1              0.000002     if s:flag.dot_repeat != 1
                                    " Store Regular Expression
    1              0.000005         let s:previous['regexp'] = a:regexp
    1              0.000004         let s:previous['direction'] = a:direction
    1              0.000003         let s:previous['operator'] = v:operator
                            
                                    " Note: 'is_inclusive' value could be changed later when
                                    " bi-directional find motion depend on 'true' direction the cursor
                                    " will move.
    1              0.000004         let s:previous['is_inclusive'] = a:is_inclusive
                            
                                    " For special motion flag
    1              0.000003         let s:previous['line_flag'] = s:flag.within_line
    1              0.000003         let s:previous['bd_t_flag'] = s:flag.bd_t " bi-directional t motion
    1              0.000001     endif "}}}
                            
                                " To avoid side effect of overwriting buffer for tpope/repeat
                                " store current b:changedtick. Use this value later
    1              0.000003     let s:current.changedtick = b:changedtick
                            
    1              0.000002     try
                                    " -- Reset properties -------------------- {{{
                                    " Save original value and set new value
    1   0.001431   0.000016         call s:SaveValue()
    1   0.000458   0.000017         call s:turn_off_hl_error()
                                    " }}}
                                    " Setup searchpos args {{{
    1              0.000004         let search_direction = (a:direction == 1 ? 'b' : '')
    1              0.000004         let search_stopline = a:direction == 1 ? win_first_line : win_last_line
                            
    1              0.000003         if s:flag.within_line == 1
    1              0.000004             let search_stopline = s:current.original_position[0]
    1              0.000001         endif
                                    "}}}
                            
                                    " Handle visual mode {{{
    1              0.000003         if ! empty(a:visualmode)
                                        " Decide at where visual mode start {{{
                                        normal! gv
                                        let v_start = [line("'<"),col("'<")] " visual_start_position
                                        let v_end   = [line("'>"),col("'>")] " visual_end_position
                            
                                        let v_original_pos = s:GetVisualStartPosition( s:current.cursor_position, v_start, v_end, search_direction)
                                        "}}}
                            
                                        " Reselect visual text {{{
                                        keepjumps call cursor(v_original_pos)
                                        exec "normal! " . a:visualmode
                                        keepjumps call cursor(s:current.cursor_position)
                                        "}}}
                                        " Update s:current.original_position
                                        " overwrite original start position
                                        let s:current.original_position = v_original_pos
                                    endif "}}}
                            
                                    " Handle bi-directional t motion {{{
    1              0.000002         if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 0) "forward
                                    else
    1              0.000003             let regexp = a:regexp
    1              0.000001         endif
                                    "}}}
                            
                                    " Handle dot repeat with count
    1              0.000001         if s:flag.count_dot_repeat
                                        let cursor_char = EasyMotion#helper#get_char_by_coord(s:current.cursor_position)
                                        if cursor_char =~# regexp
                                            call add(targets, s:current.cursor_position)
                                        endif
                                    endif
                            
                                    " Construct match dict {{{
                                    " Note: searchpos() has side effect which jump cursor position.
                                    "       You can disable this side effect by add 'n' flags,
                                    "       but in this case, it's better to allows jump side effect
                                    "       to gathering matched targets coordinates.
    1              0.000074         let pos = searchpos(regexp, search_direction . (config.accept_cursor_pos ? 'c' : ''), search_stopline)
   12              0.000012         while 1
                                        " Reached end of search range
   12              0.000032             if pos == [0, 0]
    1              0.000001                 break
                                        endif
                            
                                        " Skip folded lines {{{
   11   0.000182   0.000081             if EasyMotion#helper#is_folded(pos[0])
                                            if search_direction ==# 'b'
                                                " FIXME: Hmm... I should use filter()
                                                " keepjumps call cursor(foldclosed(pos[0]), 0)
                                            else
                                                keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                            endif
                                        else
   11              0.000033                 call add(targets, pos)
   11              0.000010             endif
                                        "}}}
   11              0.000385             let pos = searchpos(regexp, search_direction, search_stopline)
   11              0.000014         endwhile
                                    "}}}
                            
                                    " Handle bidirection "{{{
                                    " For bi-directional t motion {{{
    1              0.000002         if s:flag.bd_t == 1
                                        let regexp = s:convert_t_regexp(a:regexp, 1) "backward
                                    endif
                                    "}}}
                                    " Reconstruct match dict
    1              0.000002         if a:direction == 2
                                        " Backward
                            
                                        " Jump back cursor_position
                                        keepjumps call cursor(s:current.cursor_position[0], s:current.cursor_position[1])
                            
                                        let targets2 = []
                                        if s:flag.within_line == 0
                                            let search_stopline = win_first_line
                                        else
                                            let search_stopline = s:current.cursor_position[0]
                                        endif
                                        while 1
                                            " TODO: refactoring
                                            let pos = searchpos(regexp, 'b', search_stopline)
                                            " Reached end of search range
                                            if pos == [0, 0]
                                                break
                                            endif
                            
                                            " Skip folded lines {{{
                                            if EasyMotion#helper#is_folded(pos[0])
                                                " keepjumps call cursor(foldclosedend(pos[0]+1), 0)
                                                continue
                                            endif
                                            "}}}
                            
                                            call add(targets2, pos)
                                        endwhile
                                        " Merge match target dict"{{{
                                        let t1 = 0 " forward
                                        let t2 = 0 " backward
                                        let targets3 = []
                                        while t1 < len(targets) || t2 < len(targets2)
                                            " Forward -> Backward -> F -> B -> ...
                                            if t1 < len(targets)
                                                call add(targets3, targets[t1])
                                                let t1 += 1
                                            endif
                                            if t2 < len(targets2)
                                                call add(targets3, targets2[t2])
                                                let t2 += 1
                                            endif
                                        endwhile
                                        let targets = targets3
                                        "}}}
                                    endif
                                    "}}}
                                    " Handle no match"{{{
    1              0.000004         let targets_len = len(targets)
    1              0.000002         if targets_len == 0
                                        call s:Throw('No matches')
                                    endif
                                    "}}}
                            
                                    " Attach specific key as marker to gathered matched coordinates
    1              0.000013         let GroupingFn = function('s:GroupingAlgorithm' . s:grouping_algorithms[g:EasyMotion_grouping])
    1   0.001036   0.000110         let groups = GroupingFn(targets, split(g:EasyMotion_keys, '\zs'))
                            
                                    " -- Shade inactive source --------------- {{{
    1              0.000004         if g:EasyMotion_do_shade && targets_len != 1 && s:flag.dot_repeat != 1
    1              0.000002             if a:direction == 1 " Backward
    1              0.000004                 let shade_hl_re = s:flag.within_line ? '^.*\%#' : '\%'. win_first_line .'l\_.*\%#'
    1              0.000002             elseif a:direction == 0 " Forward
                                            let shade_hl_re = s:flag.within_line ? '\%#.*$' : '\%#\_.*\%'. win_last_line .'l'
                                        else " Both directions
                                            let shade_hl_re = s:flag.within_line ? '^.*\%#.*$' : '\_.*'
                                        endif
                            
    1   0.000039   0.000019             call EasyMotion#highlight#add_highlight( shade_hl_re, g:EasyMotion_hl_group_shade)
    1              0.000002             if g:EasyMotion_cursor_highlight
    1              0.000002                 let cursor_hl_re = '\%#'
    1   0.000019   0.000008                 call EasyMotion#highlight#add_highlight(cursor_hl_re, g:EasyMotion_hl_inc_cursor)
    1              0.000001             endif
    1              0.000001         endif
                                    " }}}
                            
                                    " -- Jump back before prompt for visual scroll {{{
                                    " Because searchpos() change current cursor position and
                                    " if you just use cursor(s:current.cursor_position) to jump back,
                                    " current line will become middle of line window
    1              0.000003         if ! empty(a:visualmode)
                                        keepjumps call winrestview({'lnum' : s:current.cursor_position[0], 'topline' : win_first_line})
                                    else
                                        " for adjusting cursorline
    1              0.000004             keepjumps call cursor(s:current.cursor_position)
    1              0.000001         endif
                                    "}}}
                            
                                    " -- Prompt user for target group/character {{{
    1              0.000002         if s:flag.dot_repeat != 1
    1   0.067285   0.000048             let coords = s:PromptUser(groups)
    1              0.000002         else
                                        let coords = s:DotPromptUser(groups)
                                    endif
                                    "}}}
                            
                                    " -- Update cursor position -------------- {{{
                                    " First, jump back cursor to original position
    1              0.000009         keepjumps call cursor(s:current.original_position)
                            
                                    " Consider EasyMotion as jump motion :h jump-motion
    1              0.000034         normal! m`
                            
                                    " Update selection for visual mode {{{
    1              0.000005         if ! empty(a:visualmode)
                                        exec 'normal! ' . a:visualmode
                                    endif
                                    " }}}
                            
                                    " For bi-directional motion, checking again whether the motion is
                                    " inclusive is necessary. This value will might be updated later
    1              0.000005         let is_inclusive_check = a:is_inclusive
                                    " For bi-directional motion, store 'true' direction for dot repeat
                                    " to handling inclusive/exclusive motion
    1              0.000002         if a:direction == 2
                                        let true_direction = EasyMotion#helper#is_greater_coords(   s:current.original_position, coords) > 0 ? 0 : 1
                                            " forward : backward
                                    else
    1              0.000003             let true_direction = a:direction
    1              0.000001         endif
                            
    1              0.000002         if s:flag.dot_repeat == 1
                                        " support dot repeat {{{
                                        " Use visual mode to emulate dot repeat
                                        normal! v
                            
                                        " Deal with exclusive {{{
                                        if s:dot_repeat.is_inclusive == 0
                                            " exclusive
                                            if s:dot_repeat.true_direction == 0 "Forward
                                                let coords[1] -= 1
                                            elseif s:dot_repeat.true_direction == 1 "Backward
                                                " Shift visual selection to left by making cursor one key
                                                " left.
                                                normal! hoh
                                            endif
                                        endif "}}}
                            
                                        " Jump to destination
                                        keepjumps call cursor(coords[0], coords[1])
                            
                                        " Execute previous operator
                                        let cmd = s:dot_repeat.operator
                                        if s:dot_repeat.operator ==# 'c'
                                            let cmd .= getreg('.')
                                        endif
                                        exec 'normal! ' . cmd
                                        "}}}
                                    else
                                        " Handle inclusive & exclusive {{{
                                        " Overwrite inclusive flag for special case {{{
    1              0.000002             if s:flag.find_bd == 1 && true_direction == 1
                                            " Note: For bi-directional find motion s(f) & t
                                            " If true_direction is backward, the motion is 'exclusive'
                                            let is_inclusive_check = 0 " overwrite
                                            let s:previous.is_inclusive = 0 " overwrite
                                        endif "}}}
    1              0.000002             if is_inclusive_check
                                            " Note: {{{
                                            " Inclusive motion requires that we eat one more
                                            " character to the right by forcing the motion to inclusive
                                            " if we're using a forward motion because
                                            " > :h exclusive
                                            " > Note that when using ':' any motion becomes characterwise
                                            " > exclusive.
                                            " and EasyMotion use ':'
                                            " See: h: o_v }}}
                                            normal! v
                                        endif " }}}
                            
    1              0.000008             if s:current.is_operator && s:flag.linewise
                                            " TODO: Is there better solution?
                                            " Maike it linewise
                                            normal! V
                                        endif
                            
                                        " Adjust screen especially for visual scroll & offscreen search {{{
                                        " Otherwise, cursor line will move middle line of window
    1              0.000052             keepjumps call winrestview({'lnum' : win_first_line, 'topline' : win_first_line})
                            
                                        " Jump to destination
    1              0.000008             keepjumps call cursor(coords[0], coords[1])
                            
                                        " To avoid side effect of overwriting buffer {{{
                                        " for tpope/vim-repeat
                                        " See: :h b:changedtick
    1              0.000005             if exists('g:repeat_tick')
                                            if g:repeat_tick == s:current.changedtick
                                                let g:repeat_tick = b:changedtick
                                            endif
                                        endif "}}}
    1              0.000001         endif
                            
                                    " Set tpope/vim-repeat {{{
    1              0.000006         if s:current.is_operator == 1 && !(v:operator ==# 'y' && match(&cpo, 'y') == -1)
                                        " Store previous info for dot repeat {{{
                                        let s:dot_repeat.regexp = a:regexp
                                        let s:dot_repeat.direction = a:direction
                                        let s:dot_repeat.line_flag = s:flag.within_line
                                        let s:dot_repeat.is_inclusive = is_inclusive_check
                                        let s:dot_repeat.operator = v:operator
                                        let s:dot_repeat.bd_t_flag = s:flag.bd_t " Bidirectional t motion
                                        let s:dot_repeat.true_direction = true_direction " Check inclusive
                                        "}}}
                                        silent! call repeat#set("\<Plug>(easymotion-dotrepeat)")
                                    endif "}}}
                            
                                    " Highlight all the matches by n-key find motions {{{
    1              0.000004         if s:current.is_search == 1 && s:current.is_operator == 0 && g:EasyMotion_add_search_history
                                        " It seems let &hlsearch=&hlsearch doesn't work when called
                                        " in script, so use :h feedkeys() instead.
                                        " Ref: :h v:hlsearch
                                        " FIXME: doesn't work with `c` operator
                                        call EasyMotion#helper#silent_feedkeys( ":let &hlsearch=&hlsearch\<CR>", 'hlsearch', 'n')
                                    endif "}}}
                            
    1   0.000367   0.000034         call s:Message('Jumping to [' . coords[0] . ', ' . coords[1] . ']')
    1              0.000006         let s:EasyMotion_is_cancelled = 0 " Success
                                    "}}}
    1              0.000002     catch /^EasyMotion:.*/
                                    redraw
                            
                                    " Show exception message
                                    " The verbose option will take precedence
                                    if g:EasyMotion_verbose == 1 && g:EasyMotion_ignore_exception != 1
                                        echo v:exception
                                    endif
                            
                                    let s:previous['regexp'] = a:regexp
                                    " -- Activate EasyMotion ----------------- {{{
                                    let s:EasyMotion_is_active = 1
                                    call EasyMotion#attach_active_autocmd() "}}}
                            
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                catch
                                    call s:Message(v:exception . ' : ' . v:throwpoint)
                                    call s:restore_cursor_state(a:visualmode)
                                    let s:EasyMotion_is_cancelled = 1 " Cancel
                                finally
                                    " -- Restore properties ------------------ {{{
    1   0.000392   0.000024         call s:RestoreValue()
    1   0.000100   0.000018         call s:turn_on_hl_error()
    1   0.000046   0.000005         call EasyMotion#reset()
                                    " }}}
                                    " -- Remove shading ---------------------- {{{
    1   0.000107   0.000008         call EasyMotion#highlight#delete_highlight()
                                    " }}}
                            
    1              0.000002         if s:EasyMotion_is_cancelled == 0 " Success
                                        " -- Landing Highlight ------------------- {{{
    1              0.000002             if g:EasyMotion_landing_highlight
                                            call EasyMotion#highlight#add_highlight(a:regexp, g:EasyMotion_hl_move)
                                            call EasyMotion#highlight#attach_autocmd()
                                        endif "}}}
                                        " -- Activate EasyMotion ----------------- {{{
    1              0.000002             let s:EasyMotion_is_active = 1
    1   0.000284   0.000016             call EasyMotion#attach_active_autocmd() "}}}
    1              0.000001         endif
    1              0.000001     endtry

FUNCTION  5()
Called 6 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    6              0.000034   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  6()
Called 2 times
Total time:   0.000033
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000009   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    2   0.000023   0.000015   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  7()
Called 34 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
   34              0.000216   call add(self._sections, [a:group, a:contents])

FUNCTION  9()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  <SNR>71_update_untracked()
Called 25 times
Total time:   0.003982
 Self time:   0.003515

count  total (s)   self (s)
   25              0.001121   let file = expand("%:p")
   25              0.000348   if empty(file) || isdirectory(file)
                                return
                              endif
                            
   25              0.000060   let needs_update = 1
   75              0.000217   for vcs in keys(s:vcs_config)
   50              0.000352     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
   50              0.000195     if has_key(s:vcs_config[vcs].untracked, file)
   25              0.000046       let needs_update = 0
   25   0.000713   0.000247       call airline#extensions#branch#update_untracked_config(file, vcs)
   25              0.000036     endif
   50              0.000045   endfor
                            
   25              0.000036   if !needs_update
   25              0.000025     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                let config = s:vcs_config[vcs]
                                if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  noa call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  noa call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
                              endfor

FUNCTION  airline#extensions#denite#apply()
Called 4 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    4              0.000024   if &ft == 'denite'
                                let w:airline_skip_empty_sections = 0
                                call a:1.add_section('airline_a', ' Denite %{airline#extensions#denite#check_denite_mode('.a:2['bufnr'].')}')
                                call a:1.add_section('airline_c', ' %{denite#get_status_sources()}')
                                call a:1.split()
                                call a:1.add_section('airline_y', ' %{denite#get_status_path()} ')
                                call a:1.add_section('airline_z', ' %{denite#get_status_linenr()} ')
                                return 1
                              endif

FUNCTION  airline#util#exec_funcrefs()
Called 6 times
Total time:   0.017992
 Self time:   0.000785

count  total (s)   self (s)
   36              0.000077     for Fn in a:list
   34   0.017700   0.000494       let code = call(Fn, a:000)
   34              0.000076       if code != 0
    4              0.000005         return code
                                  endif
   30              0.000030     endfor
    2              0.000002     return 0

FUNCTION  airline#extensions#netrw#apply()
Called 4 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    4              0.000015   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  <SNR>71_format_name()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003     return a:name

FUNCTION  dein#util#_get_lazy_plugins()
Called 3 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    3              0.000213   return filter(values(g:dein#_plugins), "!v:val.sourced && v:val.rtp !=# ''")

FUNCTION  gitgutter#process_buffer()
Called 5 times
Total time:   0.039284
 Self time:   0.000856

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    5   0.003239   0.000105   if gitgutter#utility#is_active(a:bufnr)
    5   0.000265   0.000094     if a:force || s:has_fresh_changes(a:bufnr)
                            
    3              0.000010       let diff = ''
    3              0.000008       try
    3   0.035393   0.000271         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
    3              0.000011       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    3              0.000014       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    3              0.000003     endif
    5              0.000024   endif

FUNCTION  airline#parts#iminsert()
Called 25 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
   25              0.000079   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   25              0.000023   return ''

FUNCTION  <SNR>82_exec_separator()
Called 158 times
Total time:   0.121692
 Self time:   0.010147

count  total (s)   self (s)
  158              0.000388   if pumvisible()
                                return
                              endif
  158              0.000822   let group = a:from.'_to_'.a:to.a:suffix
  158   0.030846   0.001365   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  158   0.031928   0.001460   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  158              0.000235   if a:inverse
   56              0.000387     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   56              0.000054   else
  102              0.000582     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  102              0.000114   endif
  158              0.001197   let a:dict[group] = colors
  158   0.053543   0.001947   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>55_winshell()
Called 3 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    3              0.000055   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  EasyMotion#LineAnywhere()
Called 1 time
Total time:   0.073366
 Self time:   0.000064

count  total (s)   self (s)
    1              0.000004     let s:flag.within_line = 1
    1              0.000006     let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
    1              0.000003     let re = g:EasyMotion_re_line_anywhere
    1   0.073348   0.000047     call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', 0)
    1              0.000002     return s:EasyMotion_is_cancelled

FUNCTION  dein#util#_convert2list()
Called 3 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000039   return type(a:expr) ==# v:t_list ? copy(a:expr) : type(a:expr) ==# v:t_string ?   (a:expr ==# '' ? [] : split(a:expr, '\r\?\n', 1)) : [a:expr]

FUNCTION  <SNR>85_get_seperator()
Called 26 times
Total time:   0.031194
 Self time:   0.000513

count  total (s)   self (s)
   26   0.010387   0.000215   if airline#builder#should_change_group(a:prev_group, a:group)
   26   0.020786   0.000277     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>141_PromptUser()
Called 1 time
Total time:   0.067236
 Self time:   0.050041

count  total (s)   self (s)
                                " Recursive
    1              0.000006     let group_values = values(a:groups)
                            
                                " -- If only one possible match, jump directly to it {{{
    1              0.000003     if len(group_values) == 1
                                    if mode(1) ==# 'no'
                                        " Consider jump to first match
                                        " NOTE: matchstr() handles multibyte characters.
                                        let s:dot_repeat['target'] = matchstr(g:EasyMotion_keys, '^.')
                                    endif
                                    redraw
                                    return group_values[0]
                                endif
                                " }}}
                            
                                " -- Prepare marker lines ---------------- {{{
    1              0.000002     let lines = {}
                            
    1   0.000467   0.000017     let coord_key_dict = s:CreateCoordKeyDict(a:groups)
                            
    1              0.000002     let prev_col_num = 0
   12              0.000021     for dict_key in sort(coord_key_dict[0])
                                    " NOTE: {{{
                                    " let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                                    " Perform <Plug>(easymotion-w)
                                    "
                                    " lines[line_num]['orig']:
                                    "   Lorem ipsum dolor sit amet consectetur adipisicing
                                    "
                                    " {target_char}:
                                    "   {L}orem {i}psum {d}olor {s}it {a}met {c}onsectetur {a}dipisicing
                                    "
                                    " lines[line_num]['marker'], {marker_chars}:
                                    "   {A}orem {B}psum {C}olor {D}it {E}met {F}onsectetur {G}dipisicing
                                    "   2-key-combo: {marker_chars} could be 1 or 2 chars like {AB}
                                    "
                                    " }}}
                            
                                    " Prepare original line and marker line {{{
   11              0.000091         let [line_num, col_num] = split(dict_key, ',')
                            
   11              0.000037         let line_num = str2nr(line_num)
   11              0.000032         let col_num = str2nr(col_num)
   11              0.000033         if ! has_key(lines, line_num)
    1              0.000004             let current_line = getline(line_num)
    1              0.000008             let lines[line_num] = { 'orig': current_line, 'marker': current_line, 'mb_compensation': 0, }
                                        " mb_compensation -> multibyte compensation
    1              0.000002             let prev_col_num = 0
    1              0.000001         endif "}}}
                            
                                    " Multibyte Compensation: {{{
                                    " Solve multibyte issues by matching the byte column
                                    " number instead of the visual column
                                    " Compensate for byte difference between marker
                                    " character and target character
                                    "
                                    " This has to be done in order to match the correct
                                    " column; \%c matches the byte column and not display
                                    " column.
   11              0.000069         let col_num = max([prev_col_num + 1,  col_num - lines[line_num]['mb_compensation']])
   11              0.000021         let prev_col_num = col_num
                                    "}}}
                            
                                    " Prepare marker characters {{{
   11              0.000038         let marker_chars = coord_key_dict[1][dict_key]
   11   0.000119   0.000080         let marker_chars_len = EasyMotion#helper#strchars(marker_chars)
                                    "}}}
                            
                                    " Replace {target} with {marker} & Highlight {{{
   11              0.000016         let col_add = 0 " Column add byte length
                                    " Disable two-key-combo feature?
   11              0.000037         let marker_max_length = g:EasyMotion_disable_two_key_combo == 1 ? 1 : 2
   22              0.000083         for i in range(min([marker_chars_len, marker_max_length]))
   11              0.000094             let marker_char = split(marker_chars, '\zs')[i]
                                        " EOL {{{
   11              0.000062             if strlen(lines[line_num]['marker']) < col_num + col_add
                                            " Append marker chars if target is EOL
                                            let lines[line_num]['marker'] .= ' '
                                        endif "}}}
                            
   11              0.000043             let target_col_regexp = '\%' . (col_num + col_add) . 'c.'
   11              0.000130             let target_char = matchstr(lines[line_num]['marker'], target_col_regexp)
   11              0.000055             let space_len = strdisplaywidth(target_char) - strdisplaywidth(marker_char)
                                        " Substitute marker character
   11              0.000049             let substitute_expr = marker_char . repeat(' ', space_len)
                            
   11              0.000179             let lines[line_num]['marker'] = substitute( lines[line_num]['marker'], target_col_regexp, escape(substitute_expr,'&'), '')
                            
                                        " Highlight targets {{{
   11              0.000062             let _hl_group =   (marker_chars_len == 1) ? g:EasyMotion_hl_group_target   : (i == 0) ? g:EasyMotion_hl2_first_group_target   : g:EasyMotion_hl2_second_group_target
                            
   11              0.000035             if exists('*matchaddpos')
   11   0.000243   0.000095                 call EasyMotion#highlight#add_pos_highlight( line_num, col_num + col_add, _hl_group)
   11              0.000011             else
                                            call EasyMotion#highlight#add_highlight( '\%' . line_num . 'l' . target_col_regexp, _hl_group)
                                        endif
                                        "}}}
                            
                                        " Add marker/target length difference for multibyte compensation
   11              0.000070             let lines[line_num]['mb_compensation'] += strlen(target_char) - strlen(substitute_expr)
                                        " Shift column
   11              0.000033             let col_add += strlen(marker_char)
   11              0.000013         endfor
                                    "}}}
   11              0.000008     endfor
                            
    1              0.000004     let lines_items = items(lines)
                                " }}}
                            
                                " -- Put labels on targets & Get User Input & Restore all {{{
                                " Save undo tree
    1   0.007860   0.000228     let undo_lock = EasyMotion#undo#save()
    1              0.000001     try
                                    " Set lines with markers {{{
    1   0.000059   0.000012         call s:SetLines(lines_items, 'marker')
    1              0.037561         redraw "}}}
                            
                                    " Get target character {{{
    1   0.000103   0.000035         call s:Prompt('Target key')
    1   0.008532   0.000018         let char = s:GetChar()
                                    "}}}
                            
                                    " Convert uppercase {{{
    1              0.000008         if g:EasyMotion_use_upper == 1 && match(g:EasyMotion_keys, '\l') == -1
                                        let char = toupper(char)
                                    endif "}}}
                            
                                    " Jump first target when Enter or Space key is pressed "{{{
    1              0.000012         if (char ==# "\<CR>" && g:EasyMotion_enter_jump_first == 1) ||  (char ==# "\<Space>" && g:EasyMotion_space_jump_first == 1)
                                        " NOTE: matchstr() is multibyte aware.
                                        let char = matchstr(g:EasyMotion_keys, '^.')
                                    endif "}}}
                            
                                    " For dot repeat {{{
    1              0.000005         if mode(1) ==# 'no'
                                        " Store previous target when operator pending mode
                                        if s:current.dot_prompt_user_cnt == 0
                                            " Store
                                            let s:dot_repeat['target'] = char
                                        else
                                            " Append target chars
                                            let s:dot_repeat['target'] .= char
                                        endif
                                    endif "}}}
                            
    1              0.000002     finally
                                    " Restore original lines
    1   0.000056   0.000018         call s:SetLines(lines_items, 'orig')
                            
                                    " Un-highlight targets {{{
    1   0.000251   0.000047         call EasyMotion#highlight#delete_highlight( g:EasyMotion_hl_group_target, g:EasyMotion_hl2_first_group_target, g:EasyMotion_hl2_second_group_target, )
                                    " }}}
                            
                                    " Restore undo tree
    1   0.000077   0.000020         call undo_lock.restore()
                            
    1              0.009418         redraw
    1              0.000003     endtry "}}}
                            
                                " -- Check if we have an input char ------ {{{
    1              0.000005     if empty(char)
                                    call s:Throw('Cancelled')
                                endif
                                " }}}
                                " -- Check if the input char is valid ---- {{{
    1              0.000005     if ! has_key(a:groups, char)
                                    call s:Throw('Invalid target')
                                endif
                                " }}}
                            
    1              0.000004     let target = a:groups[char]
                            
    1              0.000005     if type(target) == type([])
                                    " Return target coordinates
    1              0.000002         return target
                                else
                                    " Prompt for new target character
                                    let s:current.dot_prompt_user_cnt += 1
                                    return s:PromptUser(target)
                                endif

FUNCTION  airline#statusline()
Called 25 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
   25              0.000256   if has_key(s:contexts, a:winnr)
   25              0.000367     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 25 times
Total time:   0.162606
 Self time:   0.005845

count  total (s)   self (s)
   25              0.000139   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
   25              0.000111   let context = s:contexts[a:winnr]
                            
   25              0.000126   if get(w:, 'airline_active', 1)
   25              0.000239     let l:m = mode(1)
   25              0.000076     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
    2              0.000005       let l:mode = ['commandline']
    2              0.000003     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
   23              0.000109       let l:mode = ['normal']
   23              0.000025     endif
   25              0.000329     if index(['Rv', 'no', 'ni', 'ix', 'ic'], l:m) == -1
   25              0.000086       let l:m = l:m[0]
   25              0.000024     endif
   25              0.000198     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   25              0.000028   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   25              0.000117   if g:airline_detect_modified && &modified
    2              0.000009     call add(l:mode, 'modified')
    2              0.000002   endif
                            
   25              0.000133   if g:airline_detect_paste && &paste
   17              0.000086     call add(l:mode, 'paste')
   17              0.000016   endif
                            
   25              0.000249   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   25              0.000062   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   25              0.000054   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   25              0.000211   let mode_string = join(l:mode)
   25              0.000154   if get(w:, 'airline_lastmode', '') != mode_string
   10   0.005233   0.000200     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   10   0.150549   0.000254     call airline#highlighter#highlight(l:mode, context.bufnr)
   10   0.001519   0.000087     call airline#util#doautocmd('AirlineModeChanged')
   10              0.000036     let w:airline_lastmode = mode_string
   10              0.000008   endif
                            
   25              0.000036   return ''

FUNCTION  <SNR>71_update_git_branch()
Called 25 times
Total time:   0.005171
 Self time:   0.000957

count  total (s)   self (s)
   25   0.000312   0.000165   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
   25   0.004063   0.000338   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   25   0.000572   0.000229   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  vital#easymotion#new()
Called 2 times
Total time:   0.000045
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000043   0.000015   return s:new(s:plugin_name)

FUNCTION  <SNR>85_section_is_empty()
Called 54 times
Total time:   0.000889
 Self time:   0.000889

count  total (s)   self (s)
   54              0.000112   let start=1
                            
                              " do not check for inactive windows or the tabline
   54              0.000107   if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
   22              0.000023     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   32              0.000149   if get(g:, 'airline_skip_empty_sections', 0) == 0
   32              0.000033     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#util#append()
Called 175 times
Total time:   0.002286
 Self time:   0.002286

count  total (s)   self (s)
  175              0.000526   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  175              0.000667   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  175              0.000674   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>86_add_section()
Called 32 times
Total time:   0.007402
 Self time:   0.004400

count  total (s)   self (s)
   32              0.000218     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   32   0.001035   0.000384     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    4              0.000005       return
                                endif
   28              0.000038     if condition
                                  call a:builder.add_raw('%(')
                                endif
   28   0.005692   0.003341     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   28              0.000043     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  <SNR>55_unc_path()
Called 3 times
Total time:   0.000717
 Self time:   0.000065

count  total (s)   self (s)
    3   0.000715   0.000063   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>108_obsolete_gitgutter_signs_to_remove()
Called 3 times
Total time:   0.000172
 Self time:   0.000141

count  total (s)   self (s)
    3              0.000007   let signs_to_remove = []  " list of [<id (number)>, ...]
    3              0.000006   let remove_all_signs = 1
    3   0.000051   0.000020   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
    6              0.000018   for line_number in keys(old_gitgutter_signs)
    3              0.000015     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
    3              0.000006       let remove_all_signs = 0
    3              0.000002     endif
    3              0.000002   endfor
    3              0.000011   let s:remove_all_old_signs = remove_all_signs
    3              0.000005   return signs_to_remove

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 25 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
   25              0.000116   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  airline#themes#get_highlight()
Called 316 times
Total time:   0.059949
 Self time:   0.004471

count  total (s)   self (s)
  316   0.059742   0.004265   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>146__vital_loaded()
Called 1 time
Total time:   0.004979
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000003   let s:V = a:V
    1   0.001620   0.000019   let s:P = s:V.import('Prelude')
    1   0.003356   0.000011   let s:G = s:V.import('Vim.Guard')

FUNCTION  <SNR>141_default_config()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000012     let c = copy(s:config)
    1              0.000003     let m = mode(1)
    1              0.000004     let c.inclusive = m ==# 'no' ? s:TRUE : s:FALSE
    1              0.000002     return c

FUNCTION  <SNR>103_get_separator_change()
Called 4 times
Total time:   0.000810
 Self time:   0.000048

count  total (s)   self (s)
    4   0.000808   0.000046   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  <SNR>145__import_func_name()
Called 5 times
Total time:   0.000100
 Self time:   0.000054

count  total (s)   self (s)
    5   0.000098   0.000052   return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))

FUNCTION  vital#_easymotion#Vim#Guard#import()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000027     return map({'_vital_depends': '', '_vital_created': '', 'store': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>108_upsert_new_gitgutter_signs()
Called 3 times
Total time:   0.000346
 Self time:   0.000277

count  total (s)   self (s)
    3   0.000050   0.000019   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    3   0.000043   0.000017   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              " Handle special case where the first line is the site of two hunks:
                              " lines deleted above at the start of the file, and lines deleted
                              " immediately below.
    3              0.000020   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                let modified_lines = [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              else
    3              0.000006     let modified_lines = a:modified_lines
    3              0.000002   endif
                            
    6              0.000010   for line in modified_lines
    3              0.000007     let line_number = line[0]  " <number>
    3              0.000010     if index(other_signs, line_number) == -1  " don't clobber others' signs
    3   0.000038   0.000025       let name = s:highlight_name_for_change(line[1])
    3              0.000010       if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
    3              0.000009         let old_sign = old_gitgutter_signs[line_number]
    3              0.000008         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
    3              0.000002       endif
    3              0.000002     endif
    3              0.000002   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>145__get_module()
Called 5 times
Total time:   0.004908
 Self time:   0.000214

count  total (s)   self (s)
    5   0.000174   0.000064   let funcname = s:_import_func_name(self.plugin_name(), a:name)
    5   0.004174   0.000047   if s:_exists_autoload_func_with_source(funcname)
    5   0.000553   0.000097     return call(funcname, [])
                              else
                                return s:_get_builtin_module(a:name)
                              endif

FUNCTION  airline#extensions#tabline#buffers#get()
Called 5 times
Total time:   0.019273
 Self time:   0.000624

count  total (s)   self (s)
    5              0.000010   try
    5   0.001868   0.000063     call <sid>map_keys()
    5              0.000008   catch
                                " no-op
                              endtry
    5              0.000031   let cur = bufnr('%')
    5              0.000032   if cur == s:current_bufnr && &columns == s:column_width
    5              0.000041     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    3              0.000011       return s:current_tabline
                                endif
    2              0.000001   endif
                            
    2   0.000229   0.000026   let b = airline#extensions#tabline#new_builder()
    2              0.000009   let tab_bufs = tabpagebuflist(tabpagenr())
    2              0.000004   let show_buf_label_first = 0
                            
    2              0.000006   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
    2              0.000003   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers')
                              endif
                            
    2              0.000009   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    2              0.000004   let b.overflow_group = 'airline_tabhid'
    2   0.000033   0.000020   let b.buffers = airline#extensions#tabline#buflist#list()
    2              0.000006   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
    2              0.000005   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    2              0.000007   if has("tablineat")
    2              0.000003     function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
    2              0.000003     function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    2              0.000001   endif
                            
    2              0.000003   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    2              0.000014   let current_buffer = max([index(b.buffers, cur), 0])
    2              0.000007   let last_buffer = len(b.buffers) - 1
    2   0.000065   0.000020   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    2   0.000025   0.000014   call b.add_section('airline_tabfill', '')
    2   0.000015   0.000007   call b.split()
    2   0.000016   0.000008   call b.add_section('airline_tabfill', '')
    2              0.000004   if !show_buf_label_first
    2   0.000086   0.000020     call airline#extensions#tabline#add_label(b, 'buffers')
    2              0.000001   endif
                            
    2   0.000043   0.000018   call airline#extensions#tabline#add_tab_label(b)
                            
    2              0.000004   let s:current_bufnr = cur
    2              0.000005   let s:column_width = &columns
    2   0.016488   0.000024   let s:current_tabline = b.build()
    2              0.000010   let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
    2              0.000003   return s:current_tabline

FUNCTION  <SNR>31_airline_refresh()
Called 2 times
Total time:   0.188194
 Self time:   0.000257

count  total (s)   self (s)
    2              0.000026   if !exists("#airline")
                                " disabled
                                return
                              endif
    2   0.000732   0.000037   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.001216   0.000064   call airline#highlighter#reset_hlcache()
    2   0.164432   0.000054   call airline#load_theme()
    2   0.021704   0.000016   call airline#update_statusline()
    2   0.000065   0.000040   call airline#update_tabline()

FUNCTION  <SNR>108_remove_signs()
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000013   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . a:bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
                              else
    3              0.000006     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    3              0.000002   endif

FUNCTION  airline#util#has_fugitive()
Called 25 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   25              0.000130   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  fugitive#buffer()
Called 4 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    4              0.000026   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    4              0.000041   call extend(buffer, s:buffer_prototype, 'keep')
    4              0.000005   return buffer

FUNCTION  <SNR>71_update_hg_branch()
Called 25 times
Total time:   0.001926
 Self time:   0.001809

count  total (s)   self (s)
   25   0.000248   0.000131   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
   25              0.000096     let s:vcs_config['mercurial'].branch = ''
   25              0.000021   endif

FUNCTION  <SNR>148__vital_created()
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                              " define constant variables
    1              0.000003   if !exists('s:const')
    1              0.000002     let s:const = {}
    1              0.000005     let s:const.is_local_variable_supported = v:version > 703 || (v:version == 703 && has('patch560'))
                                " NOTE:
                                " The third argument is available from 7.4.242 but it had bug and that
                                " bug was fixed from 7.4.513
    1              0.000006     let s:const.is_third_argument_of_getreg_supported = has('patch-7.4.513')
    1              0.000002     lockvar s:const
    1              0.000001   endif
    1              0.000005   call extend(a:module, s:const)

FUNCTION  <SNR>141_SaveValue()
Called 1 time
Total time:   0.001416
 Self time:   0.000355

count  total (s)   self (s)
    1              0.000003     if ! s:current.is_search
    1   0.001112   0.000309         call EasyMotion#helper#VarReset('&scrolloff', 0)
    1              0.000001     endif
    1   0.000059   0.000008     call EasyMotion#helper#VarReset('&modified', 0)
    1   0.000046   0.000007     call EasyMotion#helper#VarReset('&modifiable', 1)
    1   0.000042   0.000006     call EasyMotion#helper#VarReset('&readonly', 0)
    1   0.000042   0.000005     call EasyMotion#helper#VarReset('&spell', 0)
    1   0.000051   0.000006     call EasyMotion#helper#VarReset('&virtualedit', '')
                                " if &foldmethod !=# 'expr'
    1   0.000056   0.000007         call EasyMotion#helper#VarReset('&foldmethod', 'manual')
                                " endif

FUNCTION  <SNR>67_invoke_funcrefs()
Called 4 times
Total time:   0.052205
 Self time:   0.000310

count  total (s)   self (s)
    4   0.000175   0.000038   let builder = airline#builder#new(a:context)
    4   0.011160   0.000077   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    4              0.000005   if err == 1
    4   0.040727   0.000053     let a:context.line = builder.build()
    4              0.000033     let s:contexts[a:context.winnr] = a:context
    4              0.000020     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    4              0.000070     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    4              0.000003   endif

FUNCTION  <SNR>89_on_exit_nvim()
Called 3 times
Total time:   0.003496
 Self time:   0.000125

count  total (s)   self (s)
    3              0.000009   if !a:exit_code
    3   0.003478   0.000107     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    3              0.000002   endif

FUNCTION  <SNR>55_dir()
Called 10 times
Total time:   0.001856
 Self time:   0.000301

count  total (s)   self (s)
   10   0.001838   0.000283   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>55_is_file_buffer()
Called 7 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    7              0.000076   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  airline#parts#filetype()
Called 25 times
Total time:   0.000548
 Self time:   0.000247

count  total (s)   self (s)
   25   0.000531   0.000230   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '‚Ä¶' : '>') : &filetype

FUNCTION  <SNR>91_is_added()
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000008   return a:from_count == 0 && a:to_count > 0

FUNCTION  airline#extensions#term#apply()
Called 4 times
Total time:   0.000193
 Self time:   0.000193

count  total (s)   self (s)
    4              0.000017   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  gitgutter#async#execute()
Called 3 times
Total time:   0.028063
 Self time:   0.027755

count  total (s)   self (s)
    3   0.000417   0.000146   call gitgutter#debug#log('[async] '.a:cmd)
                            
    3              0.000036   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    3   0.000087   0.000050   let command = s:build_command(a:cmd)
                            
    3              0.000082   if has('nvim')
    3              0.027076     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    3              0.000035   else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                              endif

FUNCTION  <SNR>145__exists_autoload_func_with_source()
Called 5 times
Total time:   0.004127
 Self time:   0.000250

count  total (s)   self (s)
    5              0.000024   if exists('*' . a:funcname)
                                " Return true if a given func is already defined
                                return 1
                              endif
                              " source a file which may include a given func definition and try again.
    5              0.000124   let path = 'autoload/' . substitute(substitute(a:funcname, '#[^#]*$', '.vim', ''), '#', '/', 'g')
    5   0.003920   0.000043   call s:_runtime(path)
    5              0.000035   return exists('*' . a:funcname)

FUNCTION  vital#_easymotion#Data#Dict#import()
Called 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000049     return map({'pick': '', 'clear': '', 'max_by': '', 'foldl': '', 'swap': '', 'omit': '', 'min_by': '', 'foldr': '', 'make_index': '', 'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>91_process_hunk()
Called 3 times
Total time:   0.000501
 Self time:   0.000238

count  total (s)   self (s)
    3              0.000006   let modifications = []
    3              0.000007   let from_line  = a:hunk[0]
    3              0.000006   let from_count = a:hunk[1]
    3              0.000005   let to_line    = a:hunk[2]
    3              0.000005   let to_count   = a:hunk[3]
                            
    3   0.000037   0.000023   if s:is_added(from_count, to_count)
    3   0.000101   0.000025     call s:process_added(modifications, from_count, to_count, to_line)
    3   0.000199   0.000025     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    3              0.000008   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
    3              0.000004   return modifications

FUNCTION  <SNR>91_save_last_seen_change()
Called 3 times
Total time:   0.000096
 Self time:   0.000026

count  total (s)   self (s)
    3   0.000095   0.000024   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  airline#extensions#tabline#buflist#list()
Called 9 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    9              0.000046   if exists('s:current_buffer_list')
    9              0.000016     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  airline#mode_changed()
Called 10 times
Total time:   0.000305
 Self time:   0.000223

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   10              0.000133   let g:airline#visual_active = (mode() =~? '[vs]')
   10   0.000143   0.000061   call airline#update_tabline()

FUNCTION  11()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000005   return len(self._sections)

FUNCTION  12()
Called 8 times
Total time:   0.053791
 Self time:   0.006876

count  total (s)   self (s)
    8              0.000016   let side = 1
    8              0.000013   let line = ''
    8              0.000013   let i = 0
    8              0.000029   let length = len(self._sections)
    8              0.000014   let split = 0
    8              0.000016   let is_empty = 0
    8              0.000018   let prev_group = ''
                            
   62              0.000244   while i < length
   54              0.000163     let section = self._sections[i]
   54              0.000136     let group = section[0]
   54              0.000127     let contents = section[1]
   54              0.000110     let pgroup = prev_group
   54   0.001421   0.000486     let prev_group = airline#builder#get_prev_group(self._sections, i)
   54              0.000195     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
   54              0.000062     if is_empty
                                  let prev_group = pgroup
                                endif
   54   0.001317   0.000428     let is_empty = s:section_is_empty(self, contents)
                            
   54              0.000056     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   54              0.000091     if group == ''
    4              0.000014       let line .= contents
    4              0.000006     elseif group == '|'
    8              0.000010       let side = 0
    8              0.000023       let line .= contents
    8              0.000009       let split = 1
    8              0.000006     else
   42              0.000072       if prev_group == ''
    8              0.000043         let line .= '%#'.group.'#'
    8              0.000010       elseif split
    8              0.000008         if !is_empty
    8   0.005886   0.000078           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    8              0.000008         endif
    8              0.000014         let split = 0
    8              0.000007       else
   26              0.000032         if !is_empty
   26   0.031468   0.000274           let line .= s:get_seperator(self, prev_group, group, side)
   26              0.000026         endif
   26              0.000033       endif
   42   0.008695   0.000606       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   42              0.000037     endif
                            
   54              0.000148     let i = i + 1
   54              0.000070   endwhile
                            
    8              0.000014   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    8              0.000012   return line

FUNCTION  <SNR>82_get_array()
Called 890 times
Total time:   0.013155
 Self time:   0.013155

count  total (s)   self (s)
  890              0.005660   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  890              0.006650   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  16()
Called 2 times
Total time:   0.000045
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000006   let self._first_title = a:first " lowest index
    2              0.000004   let self._last_title = a:last " highest index
    2              0.000004   let self._left_title = a:current " next index to add on the left
    2              0.000004   let self._right_title = a:current + 1 " next index to add on the right
    2   0.000019   0.000014   let self._left_position = self.get_position() " left end of titles
    2              0.000004   let self._right_position = self._left_position " right end of the titles

FUNCTION  17()
Called 2 times
Total time:   0.001084
 Self time:   0.000159

count  total (s)   self (s)
    2   0.000317   0.000021   let title = self.get_title(a:index)
    2   0.000591   0.000015   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    2              0.000005   if a:force || self._remaining_space >= title_size
    2              0.000004     let pos = a:pos
    2              0.000006     if has_key(self, "get_pretitle")
    2   0.000062   0.000032       call self.insert_raw(self.get_pretitle(a:index), pos)
    2              0.000005       let self._right_position += 1
    2              0.000003       let pos += 1
    2              0.000002     endif
                            
    2   0.000024   0.000014     call self.insert_section(a:group, title, pos)
    2              0.000003     let self._right_position += 1
    2              0.000003     let pos += 1
                            
    2              0.000005     if has_key(self, "get_posttitle")
    2   0.000030   0.000018       call self.insert_raw(self.get_posttitle(a:index), pos)
    2              0.000003       let self._right_position += 1
    2              0.000002       let pos += 1
    2              0.000001     endif
                            
    2              0.000004     let self._remaining_space -= title_size
    2              0.000002     return 1
                              endif
                              return 0

FUNCTION  <SNR>101_searchpos()
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000006 	let bufnr = get(a:, 1, bufnr("%"))
    1              0.000003 	let uncache = get(a:, 2, 0)
    1              0.000001 	if uncache
                            		return s:searchpos_all(a:pattern)
                            	endif
    1              0.000004 	let cache = getbufvar(bufnr, "anzu_searchpos_cache")
    1              0.000003 	if type(cache) == type("")
                            		unlet cache
                            		let cache = {}
                            	endif
                            
    1              0.000003 	if has_key(cache, a:pattern)
    1              0.000004 		return deepcopy(cache[a:pattern])
                            	endif
                            	let searchpos = s:searchpos_all(a:pattern)
                            	let cache[a:pattern] = searchpos
                            	call setbufvar(bufnr, "anzu_searchpos_cache", cache)
                            	return searchpos

FUNCTION  airline#highlighter#add_separator()
Called 34 times
Total time:   0.024652
 Self time:   0.000821

count  total (s)   self (s)
   34              0.000315   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   34   0.024311   0.000480   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>87_buffer_commit()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.343109   throw "fugitive: A third-party plugin or vimrc is calling fugitive#buffer().commit() which has been removed. Replace it with matchstr(FugitiveParse()[0], '^\x\+')"

FUNCTION  <SNR>57_wrapscan_mes()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005 	if !exists("s:start_pos") || !exists("s:is_back")
    1              0.000001 		return ""
                            	endif
                            	let prev_pos = s:start_pos
                            	let pos = getpos(".")
                            	let result = ""
                            	if !empty(prev_pos) && s:pos_less(pos, prev_pos) && !s:is_back
                            		let result = g:anzu_bottomtop_word
                            	elseif !empty(prev_pos) && s:pos_less(prev_pos, pos) && s:is_back
                            		let result = g:anzu_topbottom_word
                            	endif
                            	unlet s:start_pos
                            	unlet s:is_back
                            
                            	return result

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 3 times
Total time:   0.000174
 Self time:   0.000050

count  total (s)   self (s)
    3   0.000079   0.000022   let summary = gitgutter#hunk#summary(a:bufnr)
    3              0.000007   let summary[0] += a:count
    3   0.000085   0.000018   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#cd_cmd()
Called 3 times
Total time:   0.001439
 Self time:   0.000145

count  total (s)   self (s)
    3   0.000859   0.000080   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    3   0.000576   0.000061   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  anzu#search_status()
Called 25 times
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
   25              0.000346 	return substitute(s:status_cache, '<anzustatushighlight>.\{-}<\/anzustatushighlight>', "", "g")

FUNCTION  <SNR>148__vital_loaded()
Called 1 time
Total time:   0.002369
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000002   let s:V = a:V
    1   0.000103   0.000019   let s:Prelude = s:V.import('Prelude')
    1   0.001472   0.000024   let s:List = s:V.import('Data.List')
    1   0.000791   0.000013   let s:Dict = s:V.import('Data.Dict')

FUNCTION  airline#util#winwidth()
Called 178 times
Total time:   0.002364
 Self time:   0.002364

count  total (s)   self (s)
  178              0.000742   let nr = get(a:000, 0, 0)
  178              0.000568   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
                              else
  178              0.000446     return winwidth(nr)
                              endif

FUNCTION  airline#util#wrap()
Called 150 times
Total time:   0.001518
 Self time:   0.001243

count  total (s)   self (s)
  150   0.000920   0.000645   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
  150              0.000247   return a:text

FUNCTION  airline#util#doautocmd()
Called 12 times
Total time:   0.002127
 Self time:   0.001129

count  total (s)   self (s)
   12   0.002108   0.001111   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>145_import()
Called 6 times
Total time:   0.013571
 Self time:   0.000280

count  total (s)   self (s)
    6              0.000012   let target = {}
    6              0.000010   let functions = []
    6              0.000014   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
    6   0.005908   0.002277   let module = self._import(a:name)
    6              0.000015   if empty(functions)
    6              0.000083     call extend(target, module, 'keep')
    6              0.000005   else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
    6              0.000007   return target

FUNCTION  39()
Called 1 time
Total time:   0.000044
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000006   let undo = deepcopy(self)
    1   0.000036   0.000007   call undo._save()
    1              0.000001   return undo

FUNCTION  dein#autoload#_on_func()
Called 3 times
Total time:   0.000889
 Self time:   0.000538

count  total (s)   self (s)
    3              0.000103   let function_prefix = substitute(a:name, '[^#]*$', '', '')
    3              0.000051   if function_prefix =~# '^dein#' || function_prefix =~# '^vital#' || has('vim_starting')
                                return
                              endif
                            
    3   0.000718   0.000368   call dein#autoload#_source(filter(dein#util#_get_lazy_plugins(),  "stridx(function_prefix, v:val.normalized_name.'#') == 0   || (index(get(v:val, 'on_func', []), a:name) >= 0)"))

FUNCTION  EasyMotion#highlight#load()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                               "load

FUNCTION  <SNR>145__function()
Called 9 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    9              0.000033     return function(a:fstr)

FUNCTION  <SNR>141_SetLines()
Called 2 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    4              0.000015     for [line_num, line] in a:lines
    2              0.000049         keepjumps call setline(line_num, line[a:key])
    2              0.000004     endfor

FUNCTION  <SNR>65_is_excluded_window()
Called 4 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
    4              0.000024   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   16              0.000037   for matchw in g:airline_exclude_filenames
   12              0.000124     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   12              0.000009   endfor
                            
    4              0.000008   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    4              0.000005   return 0

FUNCTION  airline#extensions#anzu#apply()
Called 4 times
Total time:   0.000239
 Self time:   0.000055

count  total (s)   self (s)
    4   0.000236   0.000052 	call airline#extensions#append_to_section("y", " %{anzu#search_status()}")

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 7 times
Total time:   0.001596
 Self time:   0.000218

count  total (s)   self (s)
    7   0.000133   0.000074   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    7              0.000038   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    7   0.001414   0.000096   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  gitgutter#diff#parse_diff()
Called 3 times
Total time:   0.000290
 Self time:   0.000131

count  total (s)   self (s)
    3              0.000007   let hunks = []
    6              0.000029   for line in split(a:diff, '\n')
    3   0.000194   0.000035     let hunk_info = gitgutter#diff#parse_hunk(line)
    3              0.000008     if len(hunk_info) == 4
    3              0.000010       call add(hunks, hunk_info)
    3              0.000003     endif
    3              0.000003   endfor
    3              0.000004   return hunks

FUNCTION  EasyMotion#attach_active_autocmd()
Called 1 time
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
                                " Reference: https://github.com/justinmk/vim-sneak
    1              0.000003     augroup plugin-easymotion-active
    1              0.000237         autocmd!
    1              0.000012         autocmd InsertEnter,WinLeave,BufLeave <buffer> let s:EasyMotion_is_active = 0  | autocmd! plugin-easymotion-active * <buffer>
    1              0.000011         autocmd CursorMoved <buffer> autocmd plugin-easymotion-active CursorMoved <buffer> let s:EasyMotion_is_active = 0  | autocmd! plugin-easymotion-active * <buffer>
    1              0.000002     augroup END

FUNCTION  airline#extensions#tabline#new_builder()
Called 2 times
Total time:   0.000203
 Self time:   0.000098

count  total (s)   self (s)
    2              0.000028   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    2              0.000006   if get(g:, 'airline_powerline_fonts', 0)
    2              0.000012     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
    2              0.000011     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
    2              0.000002   else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
                              endif
                            
    2   0.000127   0.000021   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  10()
Called 4 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    4              0.000019   call insert(self._sections, ['', a:text], a:position)

FUNCTION  <SNR>145_plugin_name()
Called 5 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    5              0.000008   return self._plugin_name

FUNCTION  gitgutter#diff#process_hunks()
Called 3 times
Total time:   0.000586
 Self time:   0.000084

count  total (s)   self (s)
    3              0.000007   let modified_lines = []
    6              0.000012   for hunk in a:hunks
    3   0.000536   0.000035     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
    3              0.000003   endfor
    3              0.000004   return modified_lines

FUNCTION  <SNR>65_check_defined_section()
Called 4 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    4              0.000049   if !exists('w:airline_section_{a:name}')
    4              0.000036     let w:airline_section_{a:name} = g:airline_section_{a:name}
    4              0.000004   endif

FUNCTION  <SNR>55_not_git_dir()
Called 7 times
Total time:   0.001638
 Self time:   0.000296

count  total (s)   self (s)
    7   0.001627   0.000285   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  airline#extensions#tabline#add_label()
Called 2 times
Total time:   0.000066
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000007   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    2   0.000056   0.000023     call a:dict.add_section_spaced('airline_tablabel', get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    2              0.000002   endif

FUNCTION  airline#extensions#default#apply()
Called 4 times
Total time:   0.008815
 Self time:   0.000348

count  total (s)   self (s)
    4              0.000014   let winnr = a:context.winnr
    4              0.000010   let active = a:context.active
                            
    4   0.000059   0.000036   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    4   0.004727   0.000047     call s:build_sections(a:builder, a:context, s:layout[0])
    4              0.000004   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    4   0.000354   0.000072   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    4   0.000052   0.000031   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    4   0.003511   0.000049     call s:build_sections(a:builder, a:context, s:layout[1])
    4              0.000003   endif
                            
    4              0.000004   return 1

FUNCTION  <SNR>141_turn_off_hl_error()
Called 1 time
Total time:   0.000441
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000195   0.000020     let s:error_hl = EasyMotion#highlight#capture('Error')
    1   0.000048   0.000018     call EasyMotion#highlight#turn_off(s:error_hl)
    1   0.000169   0.000011     let s:matchparen_hl = EasyMotion#highlight#capture('MatchParen')
    1   0.000027   0.000008     call EasyMotion#highlight#turn_off(s:matchparen_hl)

FUNCTION  vital#_easymotion#Vim#Buffer#import()
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000056     return map({'parse_cmdarg': '', '_vital_depends': '', 'read_content': '', 'get_selected_text': '', 'is_cmdwin': '', 'edit_content': '', 'open': '', 'get_last_selected': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>72_ModifierFlags()
Called 25 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
   25              0.000120   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  EasyMotion#helper#is_folded()
Called 11 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
                                " Return false if g:EasyMotion_skipfoldedline == 1
                                " and line is start of folded lines
   11              0.000041     let _foldclosed = foldclosed(a:line)
   11              0.000037     return _foldclosed != -1 && (g:EasyMotion_skipfoldedline == 1 || a:line != _foldclosed)

FUNCTION  <SNR>87_CanAutoReloadStatus()
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000035   return get(g:, 'fugitive_autoreload_status', !has('win32'))

FUNCTION  <SNR>103_tabline_evaluated_length()
Called 10 times
Total time:   0.001190
 Self time:   0.000115

count  total (s)   self (s)
   10   0.001185   0.000111   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  anzu#get_on_pattern_pos()
Called 1 time
Total time:   0.000102
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000003 	if a:pat == ""
                            		return getpos(".")
                            	endif
    1              0.000004 	let pos = getpos(".")
    1              0.000011 	let first = searchpos(a:pat, 'nWbc')
    1              0.000010 	let last  = searchpos(a:pat, 'nWeb')
    1   0.000017   0.000012 	if s:pos_less_equal(last, first)
    1              0.000018 		let last  = searchpos(a:pat, 'nWec')
    1              0.000001 	endif
    1   0.000030   0.000012 	if s:clamp_pos(pos[1:2], first, last)
                            		return [0, first[0], first[1], 0]
                            	endif
    1              0.000001 	return pos

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 25 times
Total time:   0.002594
 Self time:   0.002410

count  total (s)   self (s)
   25              0.000093   if !exists('b:fugitive_name')
    2              0.000004     let b:fugitive_name = ''
    2              0.000002     try
    2              0.000016       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir')
    2   0.000045   0.000014         let buffer = fugitive#buffer()
    2   0.000026   0.000017         if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
    2              0.000004     endtry
    2              0.000001   endif
                            
   25   0.000310   0.000168   let fmod = s:ModifierFlags()
   25              0.000068   if empty(b:fugitive_name)
   25              0.001277     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  <SNR>57_update_search_status()
Called 1 time
Total time:   0.000327
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000003 	if mode() !=# 'n'
                            		return
                            	endif
                            
    1              0.000006 	let curs_hold = get(g:, 'anzu_enable_CursorHold_AnzuUpdateSearchStatus', 0)
    1              0.000004 	let curs_mov	= get(g:, 'anzu_enable_CursorMoved_AnzuUpdateSearchStatus', 0)
                            
    1              0.000004 	let anzu_echo_output = (curs_hold == 1 || curs_mov == 1)
                            
    1              0.000001 	try
    1              0.000002 		if curs_hold || curs_mov
    1   0.000288   0.000045 			if anzu#update(@/,	anzu#get_on_pattern_pos(@/), s:wrapscan_mes()) != -1	 && anzu_echo_output
                            				call feedkeys("\<Plug>(anzu-echohl_search_status)")
                            			endif
    1              0.000001 		endif
    1              0.000002 	catch /^Vim\%((\a\+)\)\=:E/
                            		echohl ErrorMsg | echo matchstr(v:exception, '^Vim(\a\+):\zs.*\ze$') | echohl None
                            		return
                            	endtry

FUNCTION  EasyMotion#init()
Called 1 time
Total time:   0.003692
 Self time:   0.000578

count  total (s)   self (s)
    1              0.000004     if s:loaded
                                    return
                                endif
    1              0.000004     let s:loaded = s:TRUE
    1   0.003559   0.000487     call EasyMotion#highlight#load()
                                " Store previous motion info
    1              0.000004     let s:previous = {}
                                " Store previous operator-pending motion info for '.' repeat
    1              0.000002     let s:dot_repeat = {}
                                " Prepare 1-key Migemo Dictionary
    1              0.000002     let s:migemo_dicts = {}
    1              0.000003     let s:EasyMotion_is_active = 0
    1   0.000056   0.000014     call EasyMotion#reset()
                                " Anywhere regular expression: {{{
    1              0.000009     let re = '\v' .    '(<.|^$)' . '|' .    '(.>|^$)' . '|' .    '(\l)\zs(\u)' . '|' .    '(_\zs.)' . '|' .    '(#\zs.)'
                                " 1. word
                                " 2. end of word
                                " 3. CamelCase
                                " 4. after '_' hoge_foo
                                " 5. after '#' hoge#foo
    1              0.000007     let g:EasyMotion_re_anywhere = get(g:, 'EasyMotion_re_anywhere', re)
                            
                                " Anywhere regular expression within line:
    1              0.000008     let re = '\v' .    '(<.|^$)' . '|' .    '(.>|^$)' . '|' .    '(\l)\zs(\u)' . '|' .    '(_\zs.)' . '|' .    '(#\zs.)'
    1              0.000006     let g:EasyMotion_re_line_anywhere = get(g:, 'EasyMotion_re_line_anywhere', re)
                                "}}}
                                " For other plugin
    1              0.000003     let s:EasyMotion_is_cancelled = 0
                                " 0 -> Success
                                " 1 -> Cancel
    1              0.000003     let g:EasyMotion_ignore_exception = 0
    1              0.000001     return ""

FUNCTION  neosnippet#handlers#_restore_unnamed_register()
Called 1 time
Total time:   0.000037
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000027   0.000015   let neosnippet = neosnippet#variables#current_neosnippet()
                            
    1              0.000004   if neosnippet.unnamed_register !=# '' && @" !=# neosnippet.unnamed_register
                                let @" = neosnippet.unnamed_register
                                let neosnippet.unnamed_register = ''
                              endif

FUNCTION  airline#parts#get()
Called 25 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   25              0.000144   return get(s:parts, a:key, {})

FUNCTION  FugitiveGitDir()
Called 25 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   25              0.000055   if !a:0 || a:1 ==# -1
   25              0.000097     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  gitgutter#debug#log()
Called 6 times
Total time:   0.000437
 Self time:   0.000437

count  total (s)   self (s)
    6              0.000021   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  airline#extensions#keymap#status()
Called 25 times
Total time:   0.000376
 Self time:   0.000376

count  total (s)   self (s)
   25              0.000182   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   25              0.000168     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>101_clamp_pos()
Called 1 time
Total time:   0.000018
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000018   0.000010 	return s:pos_less_equal(a:min, a:pos) && s:pos_less_equal(a:pos, a:max)

FUNCTION  neosnippet#variables#expand_stack()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004   if !exists('s:expand_stack')
                                let s:expand_stack = []
                              endif
                            
    1              0.000001   return s:expand_stack

FUNCTION  <SNR>141_RestoreValue()
Called 1 time
Total time:   0.000368
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000069   0.000009     call EasyMotion#helper#VarReset('&scrolloff')
    1   0.000116   0.000031     call EasyMotion#helper#VarReset('&modified')
    1   0.000045   0.000009     call EasyMotion#helper#VarReset('&modifiable')
    1   0.000033   0.000005     call EasyMotion#helper#VarReset('&readonly')
    1   0.000032   0.000004     call EasyMotion#helper#VarReset('&spell')
    1   0.000036   0.000004     call EasyMotion#helper#VarReset('&virtualedit')
                                " if &foldmethod !=# 'expr'
    1   0.000033   0.000005         call EasyMotion#helper#VarReset('&foldmethod')
                                " endif

FUNCTION  <SNR>108_find_current_signs()
Called 3 times
Total time:   0.000798
 Self time:   0.000590

count  total (s)   self (s)
    3              0.000007   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    3              0.000005   let other_signs = []      " [<line_number (number),...]
    3              0.000006   let dummy_sign_placed = 0
                            
    3              0.000010   redir => signs
    3              0.000063     silent execute "sign place buffer=" . a:bufnr
    3              0.000010   redir END
                            
    6              0.000062   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
    3              0.000068     let components  = split(sign_line)
    3              0.000029     let name        = split(components[2], '=')[1]
    3              0.000017     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
    3              0.000025       let line_number = str2nr(split(components[0], '=')[1])
    3              0.000012       if name =~# 'GitGutter'
    3              0.000025         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
    3              0.000011         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
    3              0.000022         let gitgutter_signs[line_number] = {'id': id, 'name': name}
    3              0.000002       else
                                    call add(other_signs, line_number)
                                  endif
    3              0.000002     end
    3              0.000003   endfor
                            
    3   0.000098   0.000024   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    3   0.000091   0.000018   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    3   0.000077   0.000017   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  gitgutter#utility#extension()
Called 3 times
Total time:   0.000639
 Self time:   0.000054

count  total (s)   self (s)
    3   0.000636   0.000051   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  airline#builder#get_prev_group()
Called 56 times
Total time:   0.000966
 Self time:   0.000966

count  total (s)   self (s)
   56              0.000133   let x = a:i - 1
   68              0.000113   while x >= 0
   56              0.000155     let group = a:sections[x][0]
   56              0.000161     if group != '' && group != '|'
   44              0.000075       return group
                                endif
   12              0.000018     let x = x - 1
   12              0.000019   endwhile
   12              0.000016   return ''

FUNCTION  airline#util#getwinvar()
Called 56 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
   56              0.000269     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
Called 25 times
Total time:   0.006061
 Self time:   0.004544

count  total (s)   self (s)
   25              0.000121   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   25              0.000189   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
   25              0.000309   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   25              0.000095   if !exists('b:airline_whitespace_check')
    1              0.000003     let b:airline_whitespace_check = ''
    1              0.000007     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000002     let trailing = 0
    1              0.000002     let check = 'trailing'
    1              0.000011     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000001       try
    1              0.000004         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000394         let trailing = search(regexp, 'nw')
    1              0.000084       catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000001     endif
                            
    1              0.000004     let mixed = 0
    1              0.000003     let check = 'indent'
    1              0.000018     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000389   0.000036       let mixed = s:check_mixed_indent()
    1              0.000003     endif
                            
    1              0.000004     let mixed_file = ''
    1              0.000003     let check = 'mixed-indent-file'
    1              0.000020     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000162   0.000034       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000003     let long = 0
    1              0.000005     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000007     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    1              0.000001   endif
   25   0.001250   0.000215   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  gitgutter#hunk#hunks()
Called 3 times
Total time:   0.000053
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000052   0.000020   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>89_on_stderr_nvim()
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000015   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif

FUNCTION  airline#themes#patch()
Called 2 times
Total time:   0.001102
 Self time:   0.001102

count  total (s)   self (s)
   26              0.000084   for mode in keys(a:palette)
   24              0.000062     if mode == 'accents'
    2              0.000004       continue
                                endif
   22              0.000144     if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
                                endif
   22              0.000107     if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
                                endif
   22              0.000103     if !has_key(a:palette[mode], 'airline_term')
                                  let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
                                endif
   22              0.000024   endfor
                            
    2              0.000024   let a:palette.accents = get(a:palette, 'accents', {})
    2              0.000024   let a:palette.accents.none = [ '', '', '', '', '' ]
    2              0.000029   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    2              0.000021   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    2              0.000010   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    2              0.000008   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
                              endif
    2              0.000008   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
                              endif
    2              0.000008   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
                              endif
    2              0.000008   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
                              endif
    2              0.000007   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
                              endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 10 times
Total time:   0.005033
 Self time:   0.000848

count  total (s)   self (s)
   10              0.000080   if getbufvar(a:bufnr, '&modified')
    1              0.000012     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    1              0.000001   else
    9              0.000214     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    9              0.000020   endif
                            
   10              0.000038   if !empty(colors)
   10   0.004370   0.000185     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   10              0.000009   endif

FUNCTION  <SNR>87_buffer_type()
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.343100   throw "fugitive: A third-party plugin or vimrc is calling fugitive#buffer().type() which has been removed. Replace it with get(b:, 'fugitive_type', '')"

FUNCTION  <SNR>73_check_mixed_indent()
Called 1 time
Total time:   0.000354
 Self time:   0.000354

count  total (s)   self (s)
    1              0.000010   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000003   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.000319     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>86_build_sections()
Called 8 times
Total time:   0.008142
 Self time:   0.000740

count  total (s)   self (s)
   40              0.000089   for key in a:keys
   32              0.000138     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
   32   0.007680   0.000278     call s:add_section(a:builder, a:context, key)
   32              0.000042   endfor

FUNCTION  dein#autoload#_source()
Called 3 times
Total time:   0.000122
 Self time:   0.000080

count  total (s)   self (s)
    3   0.000101   0.000059   let plugins = empty(a:000) ? values(g:dein#_plugins) : dein#util#_convert2list(a:1)
    3              0.000011   if empty(plugins)
    3              0.000004     return
                              endif
                            
                              if type(plugins[0]) != v:t_dict
                                let plugins = map(dein#util#_convert2list(a:1),       'get(g:dein#_plugins, v:val, {})')
                              endif
                            
                              let rtps = dein#util#_split_rtp(&runtimepath)
                              let index = index(rtps, dein#util#_get_runtime_path())
                              if index < 0
                                return 1
                              endif
                            
                              let sourced = []
                              for plugin in filter(plugins, "!empty(v:val) && !v:val.sourced && v:val.rtp !=# ''")
                                call s:source_plugin(rtps, index, plugin, sourced)
                              endfor
                            
                              let filetype_before = dein#util#_redir('autocmd FileType')
                              let &runtimepath = dein#util#_join_rtp(rtps, &runtimepath, '')
                            
                              call dein#call_hook('source', sourced)
                            
                              " Reload script files.
                              for plugin in sourced
                                for directory in filter(['plugin', 'after/plugin'], "isdirectory(plugin.rtp.'/'.v:val)")
                                  for file in dein#util#_globlist(plugin.rtp.'/'.directory.'/**/*.vim')
                                    execute 'source' fnameescape(file)
                                  endfor
                                endfor
                            
                                if !has('vim_starting')
                                  let augroup = get(plugin, 'augroup', plugin.normalized_name)
                                  if exists('#'.augroup.'#VimEnter')
                                    execute 'doautocmd' augroup 'VimEnter'
                                  endif
                                  if has('gui_running') && &term ==# 'builtin_gui' && exists('#'.augroup.'#GUIEnter')
                                    execute 'doautocmd' augroup 'GUIEnter'
                                  endif
                                  if exists('#'.augroup.'#BufRead')
                                    execute 'doautocmd' augroup 'BufRead'
                                  endif
                                endif
                              endfor
                            
                              let filetype_after = dein#util#_redir('autocmd FileType')
                            
                              let is_reset = s:is_reset_ftplugin(sourced)
                              if is_reset
                                call s:reset_ftplugin()
                              endif
                            
                              if (is_reset || filetype_before !=# filetype_after) && &filetype !=# ''
                                " Recall FileType autocmd
                                let &filetype = &filetype
                              endif
                            
                              if !has('vim_starting')
                                call dein#call_hook('post_source', sourced)
                              endif

FUNCTION  <SNR>145__runtime()
Called 5 times
Total time:   0.003878
 Self time:   0.001417

count  total (s)   self (s)
    5   0.003874   0.001414   execute 'runtime' fnameescape(a:path)

FUNCTION  airline#update_statusline_inactive()
Called 4 times
Total time:   0.000169
 Self time:   0.000154

count  total (s)   self (s)
    4   0.000039   0.000024   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    4              0.000010   for nr in a:range
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor

FUNCTION  airline#extensions#tabline#get()
Called 5 times
Total time:   0.019631
 Self time:   0.000358

count  total (s)   self (s)
    5              0.000048   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    5              0.000024   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    5              0.000019   let curtabcnt = tabpagenr('$')
    5              0.000017   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
    5              0.000033   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
    5              0.000007   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
    5   0.019346   0.000074     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 6 times
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
    6              0.000019   let cur = bufnr('%')
    6              0.000009   if cur == a:bufnr
    6              0.000029     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    3              0.000005       let group = 'airline_tabmod'
    3              0.000002     else
    3              0.000005       let group = 'airline_tabsel'
    3              0.000002     endif
    6              0.000004   else
                                if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
                                  let group = 'airline_tabhid'
                                endif
                              endif
    6              0.000007   return group

FUNCTION  EasyMotion#reset()
Called 2 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    2              0.000021     let s:flag = { 'within_line' : 0, 'dot_repeat' : 0, 'regexp' : 0, 'bd_t' : 0, 'find_bd' : 0, 'linewise' : 0, 'count_dot_repeat' : 0, }
                                    " regexp: -> regular expression
                                    "   This value is used when multi input find motion. If this values is
                                    "   1, input text is treated as regexp.(Default: escaped)
                                    " bd_t: -> bi-directional 't' motion
                                    "   This value is used to re-define regexp only for bi-directional 't'
                                    "   motion
                                    " find_bd: -> bi-directional find motion
                                    "   This value is used to recheck the motion is inclusive or exclusive
                                    "   because 'f' & 't' forward find motion is inclusive, but 'F' & 'T'
                                    "   backward find motion is exclusive
                                    " count_dot_repeat: -> dot repeat with count
                                    "   https://github.com/easymotion/vim-easymotion/issues/164
    2              0.000017     let s:current = { 'is_operator' : 0, 'is_search' : 0, 'dot_repeat_target_cnt' : 0, 'dot_prompt_user_cnt' : 0, 'changedtick' : 0, }
                                    " \ 'start_position' : [],
                                    " \ 'cursor_position' : [],
                            
                                    " is_operator:
                                    "   Store is_operator value first because mode(1) value will be
                                    "   changed by some operation.
                                    " dot_* :
                                    "   These values are used when '.' repeat for automatically
                                    "   select marker/label characters.(Using count avoid recursive
                                    "   prompt)
                                    " changedtick:
                                    "   :h b:changedtick
                                    "   This value is used to avoid side effect of overwriting buffer text
                                    "   which will change b:changedtick value. To overwrite g:repeat_tick
                                    "   value(defined tpope/vim-repeat), I can avoid this side effect of
                                    "   conflicting with tpope/vim-repeat
                                    " start_position:
                                    "   Original, start cursor position.
                                    " cursor_position:
                                    "   Usually, this values is same with start_position, but in
                                    "   visualmode and 'n' key motion, this value could be different.
    2              0.000003     return ""

FUNCTION  <SNR>103_get_separator_change_with_end()
Called 4 times
Total time:   0.000761
 Self time:   0.000116

count  total (s)   self (s)
    4              0.000008   let sep_change = 0
    4              0.000011   if !empty(a:new_end_group) " Separator between title and the end
    2   0.000665   0.000020     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    2              0.000001   endif
    4              0.000009   if !empty(a:old_group) " Separator between the title and the one adjacent
                                let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
                                if !empty(a:old_end_group) " Remove mis-predicted separator
                                  let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
                                endif
                              endif
    4              0.000005   return sep_change

FUNCTION  gitgutter#all()
Called 2 times
Total time:   0.031913
 Self time:   0.000662

count  total (s)   self (s)
    2              0.000022   let visible = tabpagebuflist()
                            
    6              0.000053   for bufnr in range(1, bufnr('$') + 1)
    4              0.000024     if buflisted(bufnr)
    2              0.000216       let file = expand('#'.bufnr.':p')
    2              0.000012       if !empty(file)
    2              0.000013         if index(visible, bufnr) != -1
    2   0.001360   0.000041           call gitgutter#init_buffer(bufnr)
    2   0.029982   0.000049           call gitgutter#process_buffer(bufnr, a:force)
    2              0.000010         elseif a:force
                                      call s:reset_tick(bufnr)
                                    endif
    2              0.000019       endif
    2              0.000003     endif
    4              0.000006   endfor

FUNCTION  <SNR>89_on_stdout_nvim()
Called 6 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    6              0.000037   if empty(self.stdoutbuffer)
    3              0.000022     let self.stdoutbuffer = a:data
    3              0.000005   else
    3              0.000035     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    3              0.000003   endif

FUNCTION  EasyMotion#highlight#add_highlight()
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000030     call add(s:h.ids[a:group], matchadd(a:group, a:re, s:priorities[a:group]))

FUNCTION  FugitiveHead()
Called 25 times
Total time:   0.003726
 Self time:   0.000526

count  total (s)   self (s)
   25   0.000379   0.000196   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   25              0.000059   if empty(dir)
                                return ''
                              endif
   25   0.003218   0.000201   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
Called 14 times
Total time:   0.274908
 Self time:   0.050118

count  total (s)   self (s)
   14              0.000057   let bufnr = a:0 ? a:1 : ''
   14              0.000086   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   14              0.000227   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   14              0.000066   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   14              0.000042   let airline_grouplist = []
   14              0.000269   let buffers_in_tabpage = sort(tabpagebuflist())
   14              0.000064   if exists("*uniq")
   14              0.000063     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   14              0.000015   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   35              0.000111   for mode in reverse(mapped)
   21              0.000222     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   13              0.000083       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  237              0.000965       for kvp in items(dict)
  224              0.000693         let mode_colors = kvp[1]
  224              0.000608         let name = kvp[0]
  224              0.001185         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  224              0.003814         if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
                                    elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  112              0.000273           continue
                                    endif
  112   0.003503   0.001745         if s:group_not_done(airline_grouplist, name.suffix)
  108   0.041530   0.001456           call airline#highlighter#exec(name.suffix, mode_colors)
  108              0.000141         endif
                            
  336              0.001464         for accent in keys(s:accents)
  224              0.001094           if !has_key(p.accents, accent)
                                        continue
                                      endif
  224              0.002005           let colors = copy(mode_colors)
  224              0.001235           if p.accents[accent][0] != ''
  112              0.000535             let colors[0] = p.accents[accent][0]
  112              0.000124           endif
  224              0.000689           if p.accents[accent][2] != ''
  112              0.000510             let colors[2] = p.accents[accent][2]
  112              0.000096           endif
  224              0.000667           if len(colors) >= 5
  224              0.001377             let colors[4] = get(p.accents[accent], 4, '')
  224              0.000361           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  224   0.006026   0.002948           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  216   0.085190   0.003172             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  216              0.000261           endif
  224              0.000324         endfor
  112              0.000155       endfor
                            
   13              0.000035       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
  137              0.000582       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  124   0.099659   0.001798         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  124              0.000239       endfor
   13              0.000012     endif
   21              0.000064   endfor

FUNCTION  <SNR>78_map_keys()
Called 5 times
Total time:   0.001805
 Self time:   0.001805

count  total (s)   self (s)
    5              0.000036   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    5              0.000030   if bidx_mode > 0
    5              0.000007     if bidx_mode == 1
   50              0.000151       for i in range(1, 9)
   45              0.001077         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
   45              0.000069       endfor
    5              0.000006     else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-11)
                                  endfor
                                endif
    5              0.000085     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    5              0.000219     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
    5              0.000007   endif

FUNCTION  airline#builder#get_next_group()
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000004   let x = a:i + 1
    2              0.000005   let l = len(a:sections)
    4              0.000005   while x < l
    4              0.000011     let group = a:sections[x][0]
    4              0.000011     if group != '' && group != '|'
    2              0.000003       return group
                                endif
    2              0.000003     let x = x + 1
    2              0.000002   endwhile
                              return ''

FUNCTION  airline#parts#ffenc()
Called 25 times
Total time:   0.000762
 Self time:   0.000762

count  total (s)   self (s)
   25              0.000116   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   25              0.000067   let bomb     = &l:bomb ? '[BOM]' : ''
   25              0.000230   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   25              0.000147   if expected is# &fenc.bomb.ff
                                return ''
                              else
   25              0.000120     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>88_has_fresh_changes()
Called 3 times
Total time:   0.000172
 Self time:   0.000089

count  total (s)   self (s)
    3   0.000167   0.000085   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  gitgutter#utility#shellescape()
Called 16 times
Total time:   0.000795
 Self time:   0.000737

count  total (s)   self (s)
   16              0.000561   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   13              0.000043     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    3              0.000021     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
Called 25 times
Total time:   0.000922
 Self time:   0.000922

count  total (s)   self (s)
   25              0.000251   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
   25              0.000641   return match(a:name, pat) > -1

FUNCTION  <SNR>82_group_not_done()
Called 336 times
Total time:   0.004836
 Self time:   0.004836

count  total (s)   self (s)
  336              0.002086   if index(a:list, a:name) == -1
  324              0.001654     call add(a:list, a:name)
  324              0.000493     return 1
                              else
   12              0.000014     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
   12              0.000009     return 0
                              endif

FUNCTION  gitgutter#async#available()
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000009   return s:available

FUNCTION  gitgutter#diff#parse_hunk()
Called 3 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
    3              0.000086   let matches = matchlist(a:line, s:hunk_re)
    3              0.000009   if len(matches) > 0
    3              0.000013     let from_line  = str2nr(matches[1])
    3              0.000015     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    3              0.000009     let to_line    = str2nr(matches[3])
    3              0.000012     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    3              0.000011     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  EasyMotion#highlight#init()
Called 1 time
Total time:   0.001122
 Self time:   0.000179

count  total (s)   self (s)
    1   0.000223   0.000042     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_target, s:target_hl_defaults)
    1   0.000160   0.000026     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_first_group_target, s:target_hl2_first_defaults)
    1   0.000150   0.000024     call EasyMotion#highlight#InitHL(g:EasyMotion_hl2_second_group_target, s:target_hl2_second_defaults)
    1   0.000136   0.000015     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_group_shade,  s:shade_hl_defaults)
    1   0.000130   0.000015     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_search, s:target_hl_inc)
    1   0.000164   0.000014     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_inc_cursor, s:target_hl_inc_cursor)
    1   0.000137   0.000020     call EasyMotion#highlight#InitHL(g:EasyMotion_hl_move, s:target_hl_move)
    1              0.000011     if exists(':CSApprox') == 2 && g:EasyMotion_force_csapprox
                                    "TODO: better solution or remove completly
                                    CSApprox!
                                endif

FUNCTION  airline#update_tabline()
Called 13 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
   13              0.000054   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
                              endif

FUNCTION  airline#load_theme()
Called 2 times
Total time:   0.164378
 Self time:   0.000327

count  total (s)   self (s)
    2              0.000024   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    2              0.000023   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
                              endif
                            
    2              0.000026   let palette = g:airline#themes#{g:airline_theme}#palette
    2   0.001149   0.000048   call airline#themes#patch(palette)
                            
    2              0.000012   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    2   0.124931   0.000045   call airline#highlighter#load_theme()
    2   0.007019   0.000054   call airline#extensions#load_theme()
    2   0.031148   0.000049   call airline#update_statusline()

FUNCTION  airline#parts#paste()
Called 25 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   25              0.000105   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>85_get_accented_line()
Called 42 times
Total time:   0.008088
 Self time:   0.008088

count  total (s)   self (s)
   42              0.000086   if a:self._context.active
                                " active window
   42              0.000101     let contents = []
   42              0.003730     let content_parts = split(a:contents, '__accent')
   92              0.000218     for cpart in content_parts
   50              0.000658       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   50              0.000191       call add(contents, cpart)
   50              0.000061     endfor
   42              0.000280     let line = join(contents, a:group)
   42              0.000423     let line = substitute(line, '__restore__', a:group, 'g')
   42              0.000041   else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   42              0.000059   return line

FUNCTION  airline#update_statusline()
Called 4 times
Total time:   0.052786
 Self time:   0.000391

count  total (s)   self (s)
    4   0.000062   0.000042   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    4              0.000040   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.000201   0.000032   call airline#update_statusline_inactive(range)
                            
    4              0.000013   unlet! w:airline_render_left w:airline_render_right
    4              0.000084   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000010   let w:airline_active = 1
    4              0.000032   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4   0.052314   0.000108   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>141_Message()
Called 1 time
Total time:   0.000333
 Self time:   0.000333

count  total (s)   self (s)
    1              0.000003     if g:EasyMotion_verbose
    1              0.000310         echo 'EasyMotion: ' . a:message
    1              0.000004     else
                                    " Make the current message disappear
                                    echo ''
                                    " redraw
                                endif

FUNCTION  airline#update_statusline_focuslost()
Called 2 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    2              0.000029   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
                              endif

FUNCTION  <SNR>141_GetChar()
Called 1 time
Total time:   0.008514
 Self time:   0.008514

count  total (s)   self (s)
    1              0.000004     let mode = get(a:, 1, 0)
    1              0.000002     while 1
                                    " Workaround for https://github.com/osyo-manga/vital-over/issues/53
    1              0.000001         try
    1              0.008423             let char = call('getchar', a:000)
    1              0.000011         catch /^Vim:Interrupt$/
                                        let char = 3 " <C-c>
                                    endtry
    1              0.000006         if char == 27 || char == 3
                                        " Escape or <C-c> key pressed
                                        redraw
                                        call s:Message('Cancelled')
                                        return ''
                                    endif
                                    " Workaround for the <expr> mappings
    1              0.000012         if string(char) !=# "\x80\xfd`"
    1              0.000012             return mode == 1 ? !!char    : type(char) == type(0) ? nr2char(char) : char
                                    endif
                                endwhile

FUNCTION  <SNR>87_AutoReloadStatus()
Called 2 times
Total time:   0.000779
 Self time:   0.000097

count  total (s)   self (s)
    2   0.000092   0.000048   if s:CanAutoReloadStatus()
    2   0.000680   0.000042     return call('fugitive#ReloadStatus', a:000)
                              endif

FUNCTION  airline#parts#readonly()
Called 25 times
Total time:   0.001537
 Self time:   0.000615

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   25   0.001218   0.000296   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
   25              0.000089   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   25              0.000055     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
Called 25 times
Total time:   0.003017
 Self time:   0.003017

count  total (s)   self (s)
   25              0.000104   let dir = a:0 > 1 ? a:2 : s:Dir()
   25              0.000827   if empty(dir) || !filereadable(dir . '/HEAD')
                                return ''
                              endif
   25              0.001103   let head = readfile(dir . '/HEAD')[0]
   25              0.000316   if head =~# '^ref: '
   25              0.000564     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  gitgutter#utility#setbufvar()
Called 21 times
Total time:   0.000518
 Self time:   0.000518

count  total (s)   self (s)
   21              0.000045   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   21              0.000063   let bvars = getbufvar(buffer, '')
   21              0.000039   if empty(bvars)
                                let bvars = {}
                              endif
   21              0.000066   let dict = get(bvars, 'gitgutter', {})
   21              0.000051   let needs_setting = empty(dict)
   21              0.000081   let dict[a:varname] = a:val
   21              0.000023   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
                              endif

FUNCTION  airline#builder#should_change_group()
Called 28 times
Total time:   0.010817
 Self time:   0.000822

count  total (s)   self (s)
   28              0.000070   if a:group1 == a:group2
                                return 0
                              endif
   28   0.005414   0.000254   let color1 = airline#highlighter#get_highlight(a:group1)
   28   0.005060   0.000225   let color2 = airline#highlighter#get_highlight(a:group2)
   28              0.000061   if g:airline_gui_mode ==# 'gui'
   28              0.000114     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#highlighter#exec()
Called 518 times
Total time:   0.184276
 Self time:   0.048585

count  total (s)   self (s)
  518              0.001480   if pumvisible()
                                return
                              endif
  518              0.001441   let colors = a:colors
  518              0.000851   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  518   0.116409   0.006079   let old_hi = airline#highlighter#get_highlight(a:group)
  518              0.001679   if len(colors) == 4
  161              0.000638     call add(colors, '')
  161              0.000123   endif
  518              0.001329   if g:airline_gui_mode ==# 'gui'
  518              0.003351     let new_hi = [colors[0], colors[1], '', '', colors[4]]
  518              0.000540   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
  518   0.018612   0.004339   let colors = s:CheckDefined(colors)
  518   0.013824   0.005051   if old_hi != new_hi || !s:hl_group_exists(a:group)
   14   0.002532   0.000217     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   14              0.000230     exe cmd
   14              0.000136     if has_key(s:hl_groups, a:group)
   14              0.000115       let s:hl_groups[a:group] = colors
   14              0.000014     endif
   14              0.000011   endif

FUNCTION  <SNR>71_display_git_branch()
Called 2 times
Total time:   0.000238
 Self time:   0.000182

count  total (s)   self (s)
    2              0.000006   let name = b:buffer_vcs_config['git'].branch
    2              0.000003   try
    2   0.000107   0.000050     let commit = fugitive#buffer().commit()
                            
                                if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
                                elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
                                endif
                              catch
    2              0.000005   endtry
                            
    2              0.000003   return name

FUNCTION  <SNR>91_write_buffer()
Called 3 times
Total time:   0.002201
 Self time:   0.002201

count  total (s)   self (s)
    3              0.000112   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    3              0.000027   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
    3              0.000027   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    3              0.000021   let fenc = getbufvar(a:bufnr, '&fileencoding')
    3              0.000014   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    3              0.000016   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='Ôªø'.bufcontents[0]
                              endif
                            
    3              0.001880   call writefile(bufcontents, a:file)

FUNCTION  airline#extensions#append_to_section()
Called 4 times
Total time:   0.000185
 Self time:   0.000091

count  total (s)   self (s)
    4   0.000158   0.000064   call <sid>check_defined_section(a:name)
    4              0.000023   let w:airline_section_{a:name} .= a:value

FUNCTION  <SNR>108_highlight_name_for_change()
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000006   if a:text ==# 'added'
    3              0.000003     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  anzu#update()
Called 1 time
Total time:   0.000134
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000003 	let pattern = a:pattern
    1              0.000002 	let cursor = a:cursor_pos
    1              0.000002 	if pattern == ""
                            		return
                            	endif
                            
    1   0.000050   0.000015 	let pos_all = s:searchpos(pattern)
                            	
    1              0.000002 	if empty(pos_all)
    1   0.000069   0.000017 		let s:status_cache = s:print_status(g:anzu_no_match_word, pattern, "", "", "")
    1              0.000001 		return -1
                            	endif
                            
                            	let index = index(pos_all, [cursor[1], cursor[2]])
                            	if index == -1
                            		return -1
                            	endif
                            
                            	let wrap_mes = get(a:, 1, "")
                            
                            	let pattern = substitute(pattern, '\\', '\\\\', 'g')
                            	let s:status_cache = s:print_status(g:anzu_status_format, pattern, index+1, len(pos_all), wrap_mes)

FUNCTION  <SNR>82_CheckDefined()
Called 518 times
Total time:   0.014273
 Self time:   0.014273

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  518              0.002929   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  518              0.002728   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  518              0.001042     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>82_GetHiCmd()
Called 14 times
Total time:   0.002315
 Self time:   0.002315

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   14              0.000031   let res = ''
   14              0.000028   let i = -1
   84              0.000129   while i < 4
   70              0.000121     let i += 1
   70              0.000317     let item = get(a:list, i, '')
   70              0.000145     if item is ''
   30              0.000063       continue
                                endif
   40              0.000050     if i == 0
   14              0.000062       let res .= ' guifg='.item
   14              0.000020     elseif i == 1
   13              0.000050       let res .= ' guibg='.item
   13              0.000015     elseif i == 2
    6              0.000036       let res .= ' ctermfg='.item
    6              0.000007     elseif i == 3
    5              0.000038       let res .= ' ctermbg='.item
    5              0.000008     elseif i == 4
    2              0.000014       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
    2              0.000002     endif
   40              0.000048   endwhile
   14              0.000028   return res

FUNCTION  <SNR>141_GroupingAlgorithmSCTree()
Called 1 time
Total time:   0.000926
 Self time:   0.000926

count  total (s)   self (s)
                                " Prepare variables for working
    1              0.000005     let targets_len = len(a:targets)
    1              0.000004     let keys_len = len(a:keys)
                            
    1              0.000002     let groups = {}
                            
    1              0.000026     let keys = reverse(copy(a:keys))
                            
                                " Semi-recursively count targets {{{
                                    " We need to know exactly how many child nodes (targets) this branch will have
                                    " in order to pass the correct amount of targets to the recursive function.
                            
                                    " Prepare sorted target count list {{{
                                        " This is horrible, I know. But dicts aren't sorted in vim, so we need to
                                        " work around that. That is done by having one sorted list with key counts,
                                        " and a dict which connects the key with the keys_count list.
                            
    1              0.000002             let keys_count = []
    1              0.000002             let keys_count_keys = {}
                            
    1              0.000002             let i = 0
   28              0.000029             for key in keys
   27              0.000052                 call add(keys_count, 0)
                            
   27              0.000064                 let keys_count_keys[key] = i
                            
   27              0.000033                 let i += 1
   27              0.000017             endfor
                                    " }}}
                            
    1              0.000003         let targets_left = targets_len
    1              0.000002         let level = 0
    1              0.000001         let i = 0
                            
    2              0.000004         while targets_left > 0
                                        " Calculate the amount of child nodes based on the current level
    1              0.000004             let childs_len = (level == 0 ? 1 : (keys_len - 1) )
                            
   11              0.000012             for key in keys
                                            " Add child node count to the keys_count array
   11              0.000034                 let keys_count[keys_count_keys[key]] += childs_len
                            
                                            " Subtract the child node count
   11              0.000020                 let targets_left -= childs_len
                            
   11              0.000013                 if targets_left <= 0
                                                " Subtract the targets left if we added too many too
                                                " many child nodes to the key count
    1              0.000003                     let keys_count[keys_count_keys[key]] += targets_left
                            
    1              0.000001                     break
                                            endif
                            
   10              0.000012                 let i += 1
   10              0.000010             endfor
                            
    1              0.000002             let level += 1
    1              0.000001         endwhile
                                " }}}
                                " Create group tree {{{
    1              0.000001         let i = 0
    1              0.000001         let key = 0
                            
    1              0.000003         call reverse(keys_count)
                            
   28              0.000031         for key_count in keys_count
   27              0.000031             if key_count > 1
                                            " We need to create a subgroup
                                            " Recurse one level deeper
                                            let groups[a:keys[key]] = s:GroupingAlgorithmSCTree(a:targets[i : i + key_count - 1], a:keys)
                                        elseif key_count == 1
                                            " Assign single target key
   11              0.000036                 let groups[a:keys[key]] = a:targets[i]
   11              0.000008             else
                                            " No target
   16              0.000017                 continue
                                        endif
                            
   11              0.000015             let key += 1
   11              0.000016             let i += key_count
   11              0.000011         endfor
                                " }}}
                            
                                " Finally!
    1              0.000002     return groups

FUNCTION  <SNR>141_Prompt()
Called 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000022     echohl Question
    1              0.000041     echo a:message . ': '
    1              0.000004     echohl None

FUNCTION  fugitive#ReloadStatus()
Called 2 times
Total time:   0.000638
 Self time:   0.000638

count  total (s)   self (s)
    2              0.000013   if exists('s:reloading_status')
                                return
                              endif
    2              0.000004   try
    2              0.000023     let s:reloading_status = 1
    2              0.000010     let mytab = tabpagenr()
    6              0.000046     for tab in [mytab] + range(1,tabpagenr('$'))
    8              0.000051       for winnr in range(1,tabpagewinnr(tab,'$'))
    4              0.000045         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          exe s:ReloadStatus()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          unlet restorewinnr
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
    4              0.000008       endfor
    4              0.000004     endfor
    2              0.000004   finally
    2              0.000007     unlet! s:reloading_status
    2              0.000003   endtry

FUNCTION  neosnippet#variables#current_neosnippet()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000004   if !exists('b:neosnippet')
                                let b:neosnippet = { 'snippets' : {}, 'selected_text' : '', 'target' : '', 'trigger' : 0, 'optional_tabstop' : 0, 'unnamed_register' : '',}
                              endif
                            
    1              0.000001   return b:neosnippet

FUNCTION  <SNR>91_process_added()
Called 3 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    3              0.000005   let offset = 0
    6              0.000012   while offset < a:to_count
    3              0.000008     let line_number = a:to_line + offset
    3              0.000012     call add(a:modifications, [line_number, 'added'])
    3              0.000006     let offset += 1
    3              0.000004   endwhile

FUNCTION  gitgutter#utility#repo_path()
Called 11 times
Total time:   0.001040
 Self time:   0.000540

count  total (s)   self (s)
   11   0.000781   0.000388   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
   11   0.000241   0.000135   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>103_evaluate_tabline()
Called 10 times
Total time:   0.001013
 Self time:   0.000663

count  total (s)   self (s)
   10              0.000021   let tabline = a:tabline
   10   0.000495   0.000145   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
   10              0.000123   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
   10              0.000081   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
   10              0.000063   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
   10              0.000051   let tabline = substitute(tabline, '%=', '', 'g')
   10              0.000050   let tabline = substitute(tabline, '%\d*\*', '', 'g')
   10              0.000032   if has('tablineat')
   10              0.000053     let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
   10              0.000008   endif
   10              0.000011   return tabline

FUNCTION  EasyMotion#highlight#add_pos_highlight()
Called 11 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   11              0.000141     call add(s:h.ids[a:group], matchaddpos(a:group, [[a:line_num, a:col_num]], s:priorities[a:group]))

FUNCTION  <SNR>82_hl_group_exists()
Called 504 times
Total time:   0.008773
 Self time:   0.008773

count  total (s)   self (s)
  504              0.002274   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  504              0.000512   return 1

FUNCTION  gitgutter#utility#windows()
Called 3 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    3              0.000053   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
Called 25 times
Total time:   0.000925
 Self time:   0.000925

count  total (s)   self (s)
   25              0.000457   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   25              0.000065   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
   25              0.000024   return ''

FUNCTION  18()
Called 2 times
Total time:   0.016464
 Self time:   0.000630

count  total (s)   self (s)
    2              0.000009   if has_key(self, '_left_position') && self._first_title <= self._last_title
    2   0.005569   0.000047     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    2              0.000009     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    2   0.000138   0.000014     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    2   0.000137   0.000013     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    2   0.000045   0.000015     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    2   0.000077   0.000023     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    2              0.000012     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    2   0.000136   0.000014     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    2              0.000004     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
                                endif
    2              0.000003     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
                                endif
                            
                                " Add the current title
    2   0.000145   0.000019     let group = self.get_group(self._left_title)
    2              0.000003     if self._left_title == self._first_title
    2   0.000109   0.000026       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
    2              0.000002     else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    2              0.000003     if self._left_title == self._last_title
    2   0.000743   0.000016       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    2              0.000002     else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    2              0.000004     let left_group = group
    2              0.000004     let right_group = group
    2   0.001104   0.000021     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    2              0.000007     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
    2              0.000005     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
                                endif
                            
    2              0.000006     while self._remaining_space > 0
    2              0.000004       let done = 0
    2              0.000005       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
                                  endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    2              0.000015       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
    2              0.000002       if !done
    2              0.000002         break
                                  endif
                                endwhile
                            
    2              0.000004     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
                                endif
                            
    2              0.000004     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
    2              0.000001   endif
                            
    2   0.007853   0.000017   return self._build()

FUNCTION  gitgutter#hunk#summary()
Called 3 times
Total time:   0.000057
 Self time:   0.000025

count  total (s)   self (s)
    3   0.000055   0.000023   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#tabline#load_theme()
Called 2 times
Total time:   0.006827
 Self time:   0.000426

count  total (s)   self (s)
    2              0.000006   if pumvisible()
                                return
                              endif
    2              0.000011   let colors    = get(a:palette, 'tabline', {})
    2              0.000010   let tablabel  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
                              " Theme for tabs on the left
    2              0.000008   let tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    2              0.000007   let tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    2              0.000016   let tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    2              0.000007   let tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    2              0.000010   let tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    2              0.000006   let tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    2              0.000011   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    2              0.000007     let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
    2              0.000002   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
                              endif
    2   0.000527   0.000023   call airline#highlighter#exec('airline_tablabel', tablabel)
    2   0.000491   0.000016   call airline#highlighter#exec('airline_tab', tab)
    2   0.000596   0.000021   call airline#highlighter#exec('airline_tabsel', tabsel)
    2   0.000490   0.000017   call airline#highlighter#exec('airline_tabtype', tabtype)
    2   0.000491   0.000016   call airline#highlighter#exec('airline_tabfill', tabfill)
    2   0.000485   0.000016   call airline#highlighter#exec('airline_tabmod', tabmod)
    2   0.000493   0.000016   call airline#highlighter#exec('airline_tabmod_unsel', tabmodu)
    2   0.000486   0.000016   call airline#highlighter#exec('airline_tabhid', tabhid)
                            
                              " Theme for tabs on the right
    2              0.000011   let tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    2              0.000009   let tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    2              0.000008   let tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    2              0.000008   let tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    2              0.000011   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    2              0.000009     let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
    2              0.000001   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
                              endif
    2   0.000485   0.000017   call airline#highlighter#exec('airline_tab_right',    tab_right)
    2   0.000496   0.000016   call airline#highlighter#exec('airline_tabsel_right', tabsel_right)
    2   0.000487   0.000016   call airline#highlighter#exec('airline_tabmod_right', tabmod_right)
    2   0.000493   0.000016   call airline#highlighter#exec('airline_tabhid_right', tabhid_right)
    2   0.000601   0.000016   call airline#highlighter#exec('airline_tabmod_unsel_right', tabmodu_right)

FUNCTION  <SNR>31_on_cursor_moved()
Called 1 time
Total time:   0.000023
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004   if winnr() != s:active_winnr
                                call s:on_window_changed()
                              endif
    1   0.000014   0.000005   call airline#update_tabline()

FUNCTION  <SNR>71_update_branch()
Called 25 times
Total time:   0.008787
 Self time:   0.001690

count  total (s)   self (s)
   75              0.000265   for vcs in keys(s:vcs_config)
   50   0.007646   0.000548     call {s:vcs_config[vcs].update_branch}()
   50              0.000241     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
   50              0.000053   endfor

FUNCTION  <SNR>145__dot_to_sharp()
Called 5 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    5              0.000044   return substitute(a:name, '\.', '#', 'g')

FUNCTION  <SNR>145__import()
Called 6 times
Total time:   0.013189
 Self time:   0.000857

count  total (s)   self (s)
    6              0.000019   if has_key(s:loaded, a:name)
    1              0.000020     return copy(s:loaded[a:name])
                              endif
    5   0.004976   0.000068   let module = self._get_module(a:name)
    5              0.000023   if has_key(module, '_vital_created')
    1   0.000039   0.000011     call module._vital_created(module)
    1              0.000001   endif
    5              0.000453   let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
    5              0.000022   let s:loaded[a:name] = export_module
    5              0.000014   if has_key(module, '_vital_loaded')
    2              0.000003     try
    2   0.000170   0.000125       call module._vital_loaded(vital#{s:plugin_name}#new())
    2              0.000002     catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
                                endtry
    2              0.000001   endif
    5              0.000063   return copy(s:loaded[a:name])

FUNCTION  EasyMotion#highlight#turn_off()
Called 2 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000010     if type(a:hl) != type([])
                                    return
                                endif
    2              0.000033     execute 'highlight ' . a:hl[0] . ' NONE'

FUNCTION  vital#easymotion#import()
Called 1 time
Total time:   0.006365
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000004   if !exists('s:V')
    1   0.000025   0.000011     let s:V = s:new(s:plugin_name)
    1              0.000001   endif
    1   0.006335   0.000020   return call(s:V.import, a:000, s:V)

FUNCTION  gitgutter#init_buffer()
Called 2 times
Total time:   0.001318
 Self time:   0.000142

count  total (s)   self (s)
    2   0.001091   0.000033   if gitgutter#utility#is_active(a:bufnr)
    2   0.000161   0.000042     let p = gitgutter#utility#repo_path(a:bufnr, 0)
    2              0.000023     if type(p) != s:t_string || empty(p)
                                  call gitgutter#utility#set_repo_path(a:bufnr)
                                  call s:setup_maps()
                                endif
    2              0.000002   endif

FUNCTION  airline#parts#crypt()
Called 25 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
   25              0.000294   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 7 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
    7              0.000035   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
    7              0.000086   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    7              0.000050   if getbufvar(a:bufnr, '&modified') == 1
    3              0.000010     let _ .= s:buf_modified_symbol
    3              0.000003   endif
    7              0.000009   return _

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 7 times
Total time:   0.001318
 Self time:   0.001092

count  total (s)   self (s)
    7              0.000036   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
    7              0.000012   let _ = ''
                            
    7              0.000028   let name = bufname(a:bufnr)
    7              0.000019   if empty(name)
                                let _ .= '[No Name]'
                              else
    7              0.000011     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/–£—á—ë–±–∞/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    7              0.000683       let _ .= pathshorten(fnamemodify(name, fmod))
    7              0.000014     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
    7              0.000043     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
    7              0.000005   endif
                            
    7   0.000308   0.000082   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  airline#extensions#branch#head()
Called 25 times
Total time:   0.014078
 Self time:   0.001067

count  total (s)   self (s)
   25              0.000107   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
   25   0.008962   0.000174   call s:update_branch()
   25   0.004154   0.000172   call s:update_untracked()
                            
   25              0.000134   if exists('b:airline_head') && !empty(b:airline_head)
   23              0.000035     return b:airline_head
                              endif
                            
    2              0.000004   let b:airline_head = ''
    2              0.000011   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    2              0.000003   let heads = []
    6              0.000009   for vcs in vcs_priority
    4              0.000012     if !empty(b:buffer_vcs_config[vcs].branch)
    2              0.000007       let heads += [vcs]
    2              0.000002     endif
    4              0.000003   endfor
                            
    4              0.000006   for vcs in heads
    2              0.000004     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    2              0.000004     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
    2   0.000286   0.000044     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    2              0.000008     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    2              0.000002   endfor
                            
    2              0.000004   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    2              0.000003   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
    2              0.000008   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '‚Ä¶' : '.')
                                endif
                              endif
                            
    2              0.000003   return b:airline_head

FUNCTION  airline#extensions#load_theme()
Called 2 times
Total time:   0.006966
 Self time:   0.000057

count  total (s)   self (s)
    2   0.006964   0.000055   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  gitgutter#diff#run_diff()
Called 3 times
Total time:   0.035123
 Self time:   0.001614

count  total (s)   self (s)
    3   0.000164   0.000039   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                sleep 5m
                              endwhile
                            
    3   0.000153   0.000036   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    3              0.000009   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    3              0.000028   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    3              0.000047   let s:counter = (s:counter + 1) % 20
    3              0.000025   let buff_file .= '.'.s:counter
                            
    3   0.000691   0.000052   let extension = gitgutter#utility#extension(a:bufnr)
    3              0.000017   if !empty(extension)
    3              0.000021     let buff_file .= '.'.extension
    3              0.000005   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    3   0.002363   0.000162   call s:write_buffer(a:bufnr, buff_file)
                            
    3              0.000026   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    3              0.000036     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    3              0.000020     let from_file .= '.'.s:counter
                            
    3              0.000017     if !empty(extension)
    3              0.000018       let from_file .= '.'.extension
    3              0.000005     endif
                            
                                " Write file from index to temporary file.
    3   0.000749   0.000070     let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000049     let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.from_file.' && '
                            
    3              0.000009   elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
    3              0.000026   let cmd .= g:gitgutter_git_executable.' --no-pager '.g:gitgutter_git_args
    3              0.000007   if s:c_flag
    3              0.000014     let cmd .= ' -c "diff.autorefreshindex=0"'
    3              0.000012     let cmd .= ' -c "diff.noprefix=false"'
    3              0.000012     let cmd .= ' -c "core.safecrlf=false"'
    3              0.000004   endif
    3              0.000037   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    3              0.000020   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    3   0.000288   0.000055     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    3              0.000004   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    3              0.000016   let cmd .= ' || exit 0'
                            
    3              0.000014   let cmd .= ')'
                            
    3   0.001497   0.000057   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    3   0.000059   0.000048   if g:gitgutter_async && gitgutter#async#available()
    3   0.028388   0.000325     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    3              0.000024     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  40()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000007   if undotree().seq_last == 0
                                " if there are no undo history, disable undo feature by setting
                                " 'undolevels' to -1 and restore it.
    1              0.000003     let self.save_undolevels = &l:undolevels
    1   0.000008   0.000007     let &l:undolevels = -1
    1              0.000002   elseif !s:Buffer.is_cmdwin()
                                " command line window doesn't support :wundo.
                                let self.undofile = tempname()
                                execute 'wundo!' self.undofile
                              else
                                let self.is_cmdwin = s:TRUE
                              endif

FUNCTION  41()
Called 1 time
Total time:   0.000057
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000007   if has_key(self, 'save_undolevels')
    1   0.000018   0.000015     let &l:undolevels = self.save_undolevels
    1              0.000002   endif
    1              0.000007   if has_key(self, 'undofile') && filereadable(self.undofile)
                                silent execute 'rundo' self.undofile
                                call delete(self.undofile)
                              endif
    1              0.000004   if has_key(self, 'is_cmdwin')
                                " XXX: it breaks undo history. AFAIK, there are no way to save and restore
                                " undo history in commandline window.
                                call self.undobreak()
                              endif

FUNCTION  vital#_easymotion#Prelude#import()
Called 1 time
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    1              0.000133     return map({'escape_pattern': '', 'is_funcref': '', 'path2directory': '', 'wcswidth': '', 'is_string': '', 'input_helper': '', 'is_number': '', 'is_cygwin': '', 'path2project_directory': '', 'strwidthpart_reverse': '', 'input_safe': '', 'is_list': '', 'truncate_skipping': '', 'glob': '', 'truncate': '', 'is_dict': '', 'set_default': '', 'is_numeric': '', 'getchar_safe': '', 'substitute_path_separator': '', 'is_mac': '', 'strwidthpart': '', 'getchar': '', 'is_unix': '', 'is_windows': '', 'globpath': '', 'escape_file_searching': '', 'is_float': '', 'smart_execute_command': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>141_turn_on_hl_error()
Called 1 time
Total time:   0.000083
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000004     if exists('s:error_hl')
    1   0.000039   0.000014         call EasyMotion#highlight#turn_on(s:error_hl)
    1              0.000004         unlet s:error_hl
    1              0.000001     endif
                            
    1              0.000003     if exists('s:matchparen_hl')
    1   0.000026   0.000006         call EasyMotion#highlight#turn_on(s:matchparen_hl)
    1              0.000003         unlet s:matchparen_hl
    1              0.000001     endif

FUNCTION  neosnippet#handlers#_cursor_moved()
Called 1 time
Total time:   0.000035
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000027   0.000018   let expand_stack = neosnippet#variables#expand_stack()
                            
                              " Get patterns and count.
    1              0.000005   if !&l:modifiable || !&l:modified || empty(expand_stack)
    1              0.000001     return
                              endif
                            
                              let expand_info = expand_stack[-1]
                              if expand_info.begin_line == expand_info.end_line && line('.') != expand_info.begin_line
                                call neosnippet#view#_clear_markers(expand_info)
                              endif

FUNCTION  <SNR>41_Highlight_Matching_Pair()
Called 2 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
                              " Remove any previous match.
    2              0.000009   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    2              0.000010   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    2              0.000007   let c_lnum = line('.')
    2              0.000006   let c_col = col('.')
    2              0.000003   let before = 0
                            
    2              0.000007   let text = getline(c_lnum)
    2              0.000053   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    2              0.000006   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    2              0.000011     let [c_before, c] = matches[1:2]
    2              0.000002   endif
    2              0.000032   let plist = split(&matchpairs, '.\zs[:,]')
    2              0.000008   let i = index(plist, c)
    2              0.000003   if i < 0
                                " not found, in Insert mode try character before the cursor
    2              0.000010     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    2              0.000002     if i < 0
                                  " not found, nothing to do
    2              0.000002       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  airline#parts#mode()
Called 25 times
Total time:   0.001643
 Self time:   0.000476

count  total (s)   self (s)
   25   0.001613   0.000446   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#quickfix#apply()
Called 4 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    4              0.000021   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  airline#util#strchars()
Called 10 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
   10              0.000030   if exists('*strchars')
   10              0.000025     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  gitgutter#diff#handler()
Called 3 times
Total time:   0.003372
 Self time:   0.000329

count  total (s)   self (s)
    3   0.000207   0.000040   call gitgutter#debug#log(a:diff)
                            
    3              0.000008   if !bufexists(a:bufnr)
                                return
                              endif
                            
    3   0.000605   0.000050   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    3   0.000689   0.000050   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    3              0.000009   let signs_count = len(modified_lines)
    3              0.000006   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    3              0.000006     if g:gitgutter_signs || g:gitgutter_highlight_lines
    3   0.001626   0.000041       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    3              0.000002     endif
    3              0.000002   endif
                            
    3   0.000123   0.000026   call s:save_last_seen_change(a:bufnr)
    3              0.000023   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  airline#extensions#wordcount#apply()
Called 4 times
Total time:   0.000266
 Self time:   0.000266

count  total (s)   self (s)
    4              0.000074   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000033   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000012   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
                              endif
                            
    4              0.000017   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
                              endif

FUNCTION  EasyMotion#highlight#InitHL()
Called 7 times
Total time:   0.000943
 Self time:   0.000943

count  total (s)   self (s)
    7              0.000043     let group_default = a:group . 'Default'
                            
                                " Prepare highlighting variables
    7              0.000083     let guihl = printf('guibg=%s guifg=%s gui=%s', a:colors.gui[0], a:colors.gui[1], a:colors.gui[2])
    7              0.000121     let ctermhl = &t_Co == 256 ? printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm256[0], a:colors.cterm256[1], a:colors.cterm256[2]) : printf('ctermbg=%s ctermfg=%s cterm=%s', a:colors.cterm[0], a:colors.cterm[1], a:colors.cterm[2])
                            
                                " Create default highlighting group
    7              0.000335     execute printf('hi default %s %s %s', group_default, guihl, ctermhl)
                            
                                " Check if the hl group exists
    7              0.000072     if hlexists(a:group)
                                    redir => hlstatus | exec 'silent hi ' . a:group | redir END
                            
                                    " Return if the group isn't cleared
                                    if hlstatus !~ 'cleared'
                                        return
                                    endif
                                endif
                            
                                " No colors are defined for this group, link to defaults
    7              0.000125     execute printf('hi default link %s %s', a:group, group_default)

FUNCTION  <SNR>73_check_mixed_indent_file()
Called 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000014   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000010   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    1              0.000003     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000024   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000056   let indent_spc  = search(head_spc, 'nw')
    1              0.000004   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    1              0.000002     return ''
                              endif

FUNCTION  airline#extensions#tabline#builder#new()
Called 2 times
Total time:   0.000106
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000078   0.000014   let builder = airline#builder#new(a:context)
    2              0.000006   let builder._build = builder.build
    2              0.000017   call extend(builder, s:prototype, 'force')
    2              0.000002   return builder

FUNCTION  <SNR>85_get_transitioned_seperator()
Called 34 times
Total time:   0.026317
 Self time:   0.001665

count  total (s)   self (s)
   34              0.000059   let line = ''
   34              0.000202   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
   34   0.024956   0.000304     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   34              0.000237     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   34              0.000180     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   34              0.000154     let line .= '%#'.a:group.'#'
   34              0.000042   endif
   34              0.000070   return line

FUNCTION  <SNR>145_new()
Called 3 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000026   let base = deepcopy(s:Vital)
    3              0.000009   let base._plugin_name = a:plugin_name
    3              0.000004   return base

FUNCTION  EasyMotion#helper#strchars()
Called 11 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
   11              0.000033         return strchars(a:str)

FUNCTION  EasyMotion#highlight#delete_highlight()
Called 2 times
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
    2              0.000020     let groups = !empty(a:000) ? a:000 : keys(s:priorities)
   12              0.000022     for group in groups
   23              0.000052         for id in s:h.ids[group]
   13              0.000076             silent! call matchdelete(id)
   13              0.000023         endfor
   10              0.000039         let s:h.ids[group] = []
   10              0.000009     endfor

FUNCTION  gitgutter#utility#is_active()
Called 7 times
Total time:   0.004191
 Self time:   0.000549

count  total (s)   self (s)
    7   0.004181   0.000538   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  airline#extensions#apply()
Called 4 times
Total time:   0.000563
 Self time:   0.000267

count  total (s)   self (s)
                            
    4   0.000329   0.000033   if s:is_excluded_window()
                                return -1
                              endif
                            
    4              0.000011   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    4              0.000008   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                              endif
                            
    4              0.000006   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    4              0.000025   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    4              0.000018   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  airline#highlighter#load_theme()
Called 2 times
Total time:   0.124886
 Self time:   0.000273

count  total (s)   self (s)
    2              0.000009   if pumvisible()
                                return
                              endif
    2              0.000050   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
    2   0.067866   0.000082   call airline#highlighter#highlight(['inactive'])
    2              0.000022   if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
                              else
    2   0.056896   0.000068     call airline#highlighter#highlight(['normal'])
    2              0.000002   endif

FUNCTION  <SNR>89_build_command()
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000016   if has('unix')
    3              0.000016     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  airline#util#has_lawrencium()
Called 25 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
   25              0.000103   return exists('*lawrencium#statusline')

FUNCTION  airline#highlighter#get_highlight()
Called 890 times
Total time:   0.175803
 Self time:   0.082268

count  total (s)   self (s)
  890              0.017159   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  890              0.008745   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
  890   0.049948   0.007985     let fg = s:get_syn(a:group, 'fg')
  890   0.046085   0.007669     let bg = s:get_syn(a:group, 'bg')
  890              0.006734     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  890              0.001447     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
                                else
  890   0.021895   0.008739       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  890              0.000853     endif
  890              0.000623   endif
  890              0.005706   let s:hl_groups[a:group] = res
  890              0.001232   return res

FUNCTION  EasyMotion#helper#VarReset()
Called 14 times
Total time:   0.000611
 Self time:   0.000589

count  total (s)   self (s)
   14              0.000073     if ! exists('s:var_reset')
    1              0.000003         let s:var_reset = {}
    1              0.000001     endif
                            
   14              0.000050     if a:0 == 0 && has_key(s:var_reset, a:var)
                                    " Reset var to original value
                                    " setbufvar( or bufname): '' or '%' can be used for the current buffer
    7   0.000083   0.000072         call setbufvar('%', a:var, s:var_reset[a:var])
    7              0.000010     elseif a:0 == 1
                                    " Save original value and set new var value
                            
    7              0.000019         let new_value = a:0 == 1 ? a:1 : ''
                            
                                    " Store original value
    7              0.000045         let s:var_reset[a:var] = getbufvar("", a:var)
                            
                                    " Set new var value
    7   0.000094   0.000084         call setbufvar('%', a:var, new_value)
    7              0.000007     endif

FUNCTION  airline#util#shorten()
Called 75 times
Total time:   0.003018
 Self time:   0.002039

count  total (s)   self (s)
   75   0.001852   0.000872   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '‚Ä¶'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'‚Ä¶'
                                endif
                              else
   75              0.000104     return a:text
                              endif

FUNCTION  <SNR>73_ws_refresh()
Called 3 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    3              0.000033   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2              0.000004     return
                              endif
    1              0.000030   unlet! b:airline_whitespace_check
    1              0.000005   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    1              0.000004   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>141_CreateCoordKeyDict()
Called 1 time
Total time:   0.000450
 Self time:   0.000450

count  total (s)   self (s)
                                " Dict structure:
                                " 1,2 : a
                                " 2,3 : b
    1              0.000002     let sort_list = []
    1              0.000002     let coord_keys = {}
    1              0.000003     let group_key = a:0 == 1 ? a:1 : ''
                            
   12              0.000037     for [key, item] in items(a:groups)
   11              0.000026         let key = group_key . key
                                    "let key = ( ! empty(group_key) ? group_key : key)
                            
   11              0.000031         if type(item) == type([]) " List
                                        " Destination coords
                            
                                        " The key needs to be zero-padded in order to
                                        " sort correctly
   11              0.000055             let dict_key = printf('%05d,%05d', item[0], item[1])
   11              0.000039             let coord_keys[dict_key] = key
                            
                                        " We need a sorting list to loop correctly in
                                        " PromptUser, dicts are unsorted
   11              0.000030             call add(sort_list, dict_key)
   11              0.000008         else
                                        " Item is a dict (has children)
                                        let coord_key_dict = s:CreateCoordKeyDict(item, key)
                            
                                        " Make sure to extend both the sort list and the
                                        " coord key dict
                                        call extend(sort_list, coord_key_dict[0])
                                        call extend(coord_keys, coord_key_dict[1])
                                    endif
                            
   11              0.000012         unlet item
   11              0.000012     endfor
                            
    1              0.000003     return [sort_list, coord_keys]

FUNCTION  <SNR>107_reset_summary()
Called 3 times
Total time:   0.000100
 Self time:   0.000026

count  total (s)   self (s)
    3   0.000096   0.000022   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  gitgutter#sign#update_signs()
Called 3 times
Total time:   0.001585
 Self time:   0.000208

count  total (s)   self (s)
    3   0.000837   0.000039   call s:find_current_signs(a:bufnr)
                            
    3              0.000022   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    3   0.000210   0.000038   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    3              0.000011   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    3              0.000004   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    3   0.000086   0.000026   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    3   0.000377   0.000031   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    3              0.000004   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  <SNR>86_get_section()
Called 40 times
Total time:   0.003040
 Self time:   0.002352

count  total (s)   self (s)
   40              0.000171   if has_key(s:section_truncate_width, a:key)
   28   0.000721   0.000256     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
   28              0.000021   endif
   40              0.000139   let spc = g:airline_symbols.space
   40              0.000256   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   40   0.000707   0.000483   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   40              0.000465   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   40              0.000246   return empty(text) ? '' : prefix.text.suffix

FUNCTION  anzu#clear_search_cache()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000006 	let bufnr = get(a:, 1, bufnr("%"))
    1              0.000010 	call setbufvar(bufnr, "anzu_searchpos_cache", {})

FUNCTION  airline#extensions#branch#get_head()
Called 25 times
Total time:   0.016305
 Self time:   0.001255

count  total (s)   self (s)
   25   0.014252   0.000174   let head = airline#extensions#branch#head()
   25   0.000376   0.000220   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   25              0.000134   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   25   0.000994   0.000178   let head = airline#util#shorten(head, winwidth, minwidth)
   25              0.000136   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   25              0.000122   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   25              0.000233   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  EasyMotion#highlight#capture()
Called 2 times
Total time:   0.000333
 Self time:   0.000325

count  total (s)   self (s)
                                " Based On: https://github.com/t9md/vim-ezbar
                                "           https://github.com/osyo-manga/vital-over
    2              0.000006     let hlname = a:hlname
    2              0.000013     if !hlexists(hlname)
                                    return
                                endif
    2              0.000004     while 1
    2              0.000007         let save_verbose = &verbose
    2   0.000019   0.000013         let &verbose = 0
    2              0.000003         try
    2              0.000008             redir => HL_SAVE
    2              0.000032             execute 'silent! highlight ' . hlname
    2              0.000008             redir END
    2              0.000003         finally
    2   0.000014   0.000012             let &verbose = save_verbose
    2              0.000003         endtry
    2              0.000027         if !empty(matchstr(HL_SAVE, 'xxx cleared$'))
                                        return ''
                                    endif
                                    " follow highlight link
    2              0.000019         let ml = matchlist(HL_SAVE, 'links to \zs.*')
    2              0.000005         if !empty(ml)
                                        let hlname = ml[0]
                                        continue
                                    endif
    2              0.000002         break
                                endwhile
    2              0.000108     let HL_SAVE = substitute(matchstr(HL_SAVE, 'xxx \zs.*'), '[ \t\n]\+', ' ', 'g')
    2              0.000007     return [hlname, HL_SAVE]

FUNCTION  gitgutter#utility#getbufvar()
Called 36 times
Total time:   0.000901
 Self time:   0.000901

count  total (s)   self (s)
   36              0.000498   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   36              0.000175   if has_key(dict, a:varname)
   29              0.000089     return dict[a:varname]
                              else
    7              0.000014     if a:0
    7              0.000016       return a:1
                                endif
                              endif

FUNCTION  vital#_easymotion#Data#List#import()
Called 1 time
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
    1              0.000184     return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>55_abs_path()
Called 23 times
Total time:   0.003619
 Self time:   0.003619

count  total (s)   self (s)
   23              0.003331   let p = resolve(expand('#'.a:bufnr.':p'))
   23              0.000250   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  EasyMotion#undo#save()
Called 1 time
Total time:   0.000056
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000056   0.000011   return s:undo_lock.save()

FUNCTION  airline#highlighter#reset_hlcache()
Called 2 times
Total time:   0.001152
 Self time:   0.001152

count  total (s)   self (s)
    2              0.001149   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
Called 50 times
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
   50              0.000158   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
   50              0.000190   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>101_pos_less_equal()
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000012 	return a:a[0] == a:b[0] ? a:a[1] <= a:b[1] : a:a[0] <= a:b[0]

FUNCTION  EasyMotion#highlight#turn_on()
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000008     if type(a:hl) != type([])
                                    return
                                endif
    2              0.000033     execute 'highlight ' . a:hl[0] . ' ' . a:hl[1]

FUNCTION  <SNR>82_get_syn()
Called 1780 times
Total time:   0.080380
 Self time:   0.080380

count  total (s)   self (s)
 1780              0.008767   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1780              0.003141   let color = ''
 1780              0.007670   if hlexists(a:group)
 1748              0.014825     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1748              0.001742   endif
 1780              0.006350   if empty(color) || color == -1
                                " should always exists
   44              0.001048     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   44              0.000230     if empty(color) || color == -1
   22              0.000091       let color = 'NONE'
   22              0.000025     endif
   44              0.000039   endif
 1780              0.002619   return color

FUNCTION  <SNR>55_exists_file()
Called 7 times
Total time:   0.001647
 Self time:   0.000365

count  total (s)   self (s)
    7   0.001640   0.000357   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>101_print_status()
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000002 	let result = a:format
    1              0.000010 	let result = substitute(result, '%#\(.\{-}\)#', '<anzustatushighlight>\1<\/anzustatushighlight>', "g")
    1              0.000007 	let result = substitute(result, '%i', a:index, "g")
    1              0.000006 	let result = substitute(result, '%l', a:len, "g")
    1              0.000005 	let result = substitute(result, '%w', a:wrap, "g")
    1              0.000005 	let result = substitute(result, '%p', a:pattern, "g")
                            	" Fix \<homu\> to view
    1              0.000013 	let result = substitute(result, '%/', substitute(histget("/", -1), '\\', '\\\\', "g"), "g")
    1              0.000001 	return result

FUNCTION  airline#extensions#tabline#add_tab_label()
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000011   if get(g:, 'airline#extensions#tabline#show_tab_count', 1) && tabpagenr('$') > 1
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 3 times
Total time:   0.000265
 Self time:   0.000066

count  total (s)   self (s)
    3   0.000139   0.000040   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    3   0.000124   0.000024   call s:reset_summary(a:bufnr)

FUNCTION  airline#builder#new()
Called 6 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
    6              0.000054   let builder = copy(s:prototype)
    6              0.000017   let builder._context = a:context
    6              0.000014   let builder._sections = []
                            
    6              0.000095   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    6              0.000008   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   14   0.274908   0.050118  airline#highlighter#highlight()
    2   0.188194   0.000257  <SNR>31_airline_refresh()
  518   0.184276   0.048585  airline#highlighter#exec()
  890   0.175803   0.082268  airline#highlighter#get_highlight()
    2   0.164378   0.000327  airline#load_theme()
   25   0.162606   0.005845  airline#check_mode()
    2   0.124886   0.000273  airline#highlighter#load_theme()
  158   0.121692   0.010147  <SNR>82_exec_separator()
 1780   0.080380             <SNR>82_get_syn()
    1   0.073366   0.000064  EasyMotion#LineAnywhere()
    1   0.073302   0.001938  <SNR>141_EasyMotion()
    1   0.067236   0.050041  <SNR>141_PromptUser()
  316   0.059949   0.004471  airline#themes#get_highlight()
    8   0.053791   0.006876  12()
    4   0.052786   0.000391  airline#update_statusline()
    4   0.052205   0.000310  <SNR>67_invoke_funcrefs()
    5   0.039284   0.000856  gitgutter#process_buffer()
    3   0.035123   0.001614  gitgutter#diff#run_diff()
    2   0.031913   0.000662  gitgutter#all()
   26   0.031194   0.000513  <SNR>85_get_seperator()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  890   0.175803   0.082268  airline#highlighter#get_highlight()
 1780              0.080380  <SNR>82_get_syn()
   14   0.274908   0.050118  airline#highlighter#highlight()
    1   0.067236   0.050041  <SNR>141_PromptUser()
  518   0.184276   0.048585  airline#highlighter#exec()
    3   0.028063   0.027755  gitgutter#async#execute()
  518              0.014273  <SNR>82_CheckDefined()
  890              0.013155  <SNR>82_get_array()
  158   0.121692   0.010147  <SNR>82_exec_separator()
  504              0.008773  <SNR>82_hl_group_exists()
    1              0.008514  <SNR>141_GetChar()
   42              0.008088  <SNR>85_get_accented_line()
    8   0.053791   0.006876  12()
   25   0.162606   0.005845  airline#check_mode()
  336              0.004836  <SNR>82_group_not_done()
   25   0.006061   0.004544  airline#extensions#whitespace#check()
  316   0.059949   0.004471  airline#themes#get_highlight()
   32   0.007402   0.004400  <SNR>86_add_section()
   23              0.003619  <SNR>55_abs_path()
   25   0.003982   0.003515  <SNR>71_update_untracked()

